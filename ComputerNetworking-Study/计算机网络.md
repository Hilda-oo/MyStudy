#  计算机网络

## 1、应用层

### 1.1 网络应用的体系结构

> 网络应用的特点，与单机应用的本质性的不同：在网络的两端都会有一些软件或应用程序进行交互。

#### 1.1.1 客户机/服务器结构（Client/Server,C/S）

1. 一个服务器，很多个客户机使用服务，服务器对外提供服务。
2. 服务器
   - 永久性访问地址、域名（不能随意改）
   - 7*24小时提供服务
   - 利用大量服务器实现可扩展性，同时处理大量用户的请求。
3. 客户机
   - 与服务器通信
   - 间歇性接入网络，使用时才接入。
   - 可能使用动态的IP地址，因为不需要对外提供服务。
   - 客户机之间不会直接通信
4. 例子：Web。服务器上运行Web服务器软件，响应请求；常见的客户机就是PC、Mac等，运行着一些浏览器，发送请求。

#### 1.1.2 点对点结构（Peer-to-Peer,P2P）

1. 特点：
   - 没有永远在线的服务器，主机都是平等的
   - 任意端系统/节点之间可以直接通讯
   - 间歇性接入网络（使用时）
   - 可能改变IP地址
   - 例子：文件共享、文件下载

2. 与C/S有什么不同？或者说比较C/S，P2P有什么优缺点？

   - 优点：高度可伸缩。

   - 缺点：实现复杂，难于管理。

#### 1.1.3 混合结构（Hybrid）（前两者混合）

1. 例子：Napster

   - 文件传输使用P2P结构

   - 文件搜索使用C/S结构——集中式。每个节点向中央服务器报告自己的内容（文件名、文件属性等）或者提交查询请求（文件名、文件属性等）。

   > 下图说明：
   >
   > 1. 因为是混合结构，所以需要一个中央服务器；
   > 2. 中央服务器和利用者、提供者构成C/S结构；
   > 3. 利用者和提供者之间直接传输文件构成P2P结构。
   >
   >![20210410205049919](https://github.com/Hilda-oo/MyStudy/blob/master/ComputerNetworking-Study/Images/image-20210410205049919.png)

思考题：

1. 为每种体系结构找出5种以上的网络应用。
2. 从多个方面/角度对比三种体系结构的优缺点。





###  1.2 网络应用的需求与传输服务

#### 1.2.1 主要需求：

1. 数据丢失（data loss）/可靠性（reliability）

   - 有些网络能够容忍一定的数据丢失：网络电话、视频（表现为视频质量不佳）

   - 相反有些网络要求100%可靠的传输：网上银行

2. 时间(timing)/延迟(delay)
   - 有些应用只有在延迟足够低时才有效
   - 另一种情况：网络电话/网络游戏，比如打电话对方已经说话了，但是过了一分钟才传到己方这边。
   - 当延迟高到一定程度时，可以说这个网络应用实际上已经无效了。

3. 带宽(bandwidth)

   - 某些应用只有在带宽达到最低要求时才“有效”。
     - 比如网络在线看视频，如果带宽比较低的话，视频是很卡的，不连续的。

   - 弹性应用：可以适应任何带宽
     - 比如：email、文件下载（网速快、下得快，网速慢、下的慢，但都能下）

4. 还有一些其他的，比如说安全性的要求。

5. 典型网络应用对传输服务的需求 

   ![image-20210410205143035](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205143035.png)

   

   

#### 1.2.2 Internet（主流网络）提供的传输服务

1. TCP服务
   - 面向连接：客户机/服务器进程间需要建立连接。
   - 可靠的传输：可以将底层的不可靠转化为可靠的。
   - 流量控制：发送方不会发送速度过快，超过接收方的处理能力。
   - 拥塞控制：对整个网络启动的机制，当网络负载过重时能够限制发送方的发送速度。
   - 不提供时间/延迟保障、最小带宽保障

2. UDP服务

   - 无连接
   - 不可靠的数据传输
   - 不提供可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障
   - UDP做的是任何一个传输层服务都必须要做的基本的事情，除此之外都不做。其优点传输过来限制少，使得在应用层可以做很多事情。

3. 典型网络应用所使用的传输层服务

   ![image-20210410205210192](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205210192.png)

   



### 1.3 Web应用

> 万维网（World Wide Web）发明人：Tim Berners-Lee

#### 1.3.1 Web构成

1. Web的构成是一个一个网页，并且网页之间互相连接，从而形成一个庞大的信息网络和内容网络，甚至发展成服务网络。
2. 网页（Web Page）包含多个对象：
   - HTML文件、JPEG图片、视频文件、动态脚本等。
   - 包含基本HTML文件：包含对其他对象引用的链接。
3. 对象的寻址（addressing）
   - Web对象的标识是URL（Uniform Resource Locator），即统一资源定位器。
   - URL基本格式：Scheme://host:port/path（协议://主机的域名或IP地址：端口号/路径）
   - 例子：**www.someshool.edu/**someDept/pic.gif。其中协议被省略，默认为HTTP://，加粗部分是主机名，剩余部分为路径（具体到文件pic.gif）。

#### 1.3.2 HTTP协议概述

> 万维网应用遵循 **超文本传输协议（HyperText Transfer Protocol，HTTP）**。

1. 采用C/S结构

   - 客户——Browser：浏览器，作用是请求、接收、展示Web对象。
   - 服务器——Web Server：响应客户的请求，发送对象。
     - 最典型的WebServer软件是Apache软件，是现在事实上的标准。

2. HTTP版本：

   - 1.0：RFC 1945
   - 1.1：RFC 2068

3. 使用TCP传输服务：流程如下

   - 服务器在 **80端口** 等待客户的请求
   - 浏览器发起到服务器的 **TCP连接**（创建套接字 **Socket**）
   - 服务器接受来自浏览器的TCP连接
   - 浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息（请求和响应消息）
   - **关闭TCP连接**

4. HTTP应用协议是一个**无状态**应用协议，服务器 **不维护** 任何有关客户端过去所发请求的消息（即使是2分钟前）。

   - 一般来说更喜欢使用无状态机制，因为有状态的协议更复杂：

     > 需要维护状态（维护历史信息）；如果客户或服务器失效，会产生状态不一致，解决这种问题代价高。

#### 1.3.3 HTTP连接

> HTTP依靠TCP建立连接。

1. HTTP连接的两种类型

   - 非持久性连接（Nonpersistent HTTP）

     - 每个TCP连接最多允许传输 **一个** 对象，然后就会被关闭。HTTP1.0早期版本使用这种机制。

     

   - 持久性连接（Persistent HTTP）

     - 每个TCP连接允许传输 **多个** 对象，HTTP1.1版本使用这种机制。

   - 两者之间的不同？

2. 非持久性连接（以例子说明）

   - 详细例子

     ![image-20210410205302891](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205302891.png)

       ![image-20210410205401765](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205401765.png)

     

   - 一个非持久性连接的**响应时间分析与建模**

     > RTT(Round Trip Time):**从**客户端**发送**一个很小的数据包**到**服务器并**返回**所经历的时间。

     响应时间(Response time) 分解:

     - 发起、建立TCP连接：1个RTT

     - 发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT

     - 响应消息中所含文件/对象传输时间（完全接收响应消息，包含解析、文件之类的）。

     - 总结：Total = 2RTT+文件发送时间

       ![image-20210410205435540](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205435540.png)

       

   - 特性总结：
     1. 一个TCP连接只允许传输 **一个** 对象，然后就会被关闭。
     2. 一次非持久性连接的响应时间为：Total = 2RTT+文件发送时间。
   - 缺点：
     - 慢：每个对象都需要2个RTT以上的时间才能获得（**串行**）。
     - 操作系统需要为每个TCP连接开销资源（overhead）。

   > 于是就会想可以并行吗？但是就会给服务器端造成很大的负担。TCP连接是一个宝贵资源，都是需要代价的。

3. 持久性连接（改进）

   - 发送响应之后，服务器保持TCP连接的打开状态，后续的HTTP消息可以通过这个连接继续发送。
   - 无流水(pipelining)的持久性连接：
     - 客户端只有收到前一个响应后才发送新的请求。
     - 每个被引用的对象耗时1个RTT。
   - 带有流水机制的持久性连接（HTTP1.1的默认选项）
     - 客户端只要遇到**一个**引用对象就尽快发出请求
     - 理想情况下，收到**所有的**引用对象只需耗时约1个RTT。



#### 1.3.4 HTTP消息格式

1. HTTP协议有两类消息：请求消息（request）、响应消息（response）。都是使用ASCII码，直接可读。

2. 请求消息

   例如：![image-20210410205510933](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205510933.png)

   格式：

   ![image-20210410205626120](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205626120.png)

   

   - 请求消息会携带数据吗？
     - 会，比如说某些请求需要填写用户名信息等，这些被放在 **Entity Body** 消息体中。
   - 那如何上传输入数据呢？
     - POST方法：在请求消息的消息体中上传客户端的输入，然后服务器从消息体获取数据。
     - URL方法：当上传输入的消息较少时，使用GET方法，输入信息通过request行的URL字段上传。
   - HTTP中方法的类型：
     - HTTP/1.0
       - GET方法：从浏览器中获得东西
       - POST方法：向服务器中提交数据
       - HEAD方法：请服务器不要将所请求的对象放入响应消息中。
     - HTTP/1.1
       - PUT：将消息体中的文件上传到URL字段所指定的路径。可以支持向WEB上传文件并保存。
       - DELETE：删除URL字段所指的文件。

3. 响应消息

   例如：

   ![image-20210410205532511](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205532511.png)

   

   - 响应状态码：
     - 200 OK
     - 301 该网页被永久性移走（Moved Permanently）
     - 400 （Bad Request）
     - 404  找不到网页（Not Found）
     - 505 （HTTP Version Not Supported）



#### 1.3.5 Cookie技术

1. 为什么需要Cookie技术

   HTTP协议是无状态的，但是很多应用需要服务器掌握客户端的状态，需要会话状态的，如网上购物。所以需要Cookie技术。

2. Cookie技术的含义

   - Cookie技术是某些网站为了辨别用户身份、进行session跟踪而**储存在用户本地终端上的数据**（通常需要加密）。
   - RFC6265

3. Cookie的组件

   - HTTP响应消息的cookie头部行
   - HTTP请求消息的cookie头部行
   - 保存在客户端主机上的cookie文件，由浏览器管理。
   - web服务器的后台数据

4. Cookie原理

   ![image-20210410205828108](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205828108.png)

   

5. Cookie的作用

   - 身份认证
   - 购物车
   - 推荐……

6. 隐私问题



#### 1.3.6 Web缓存/代理服务器技术

1. 功能

   在不访问服务器的前提下满足客户端的HTTP请求。

2. 性能（即为什么要发明这项技术？）

   - 缩短客户请求的响应时间
   - 减少机构/组织的流量
   - 在大范围网络内实现有效的内容分发

3. 结构

   - 增加一个缓存/代理服务器。用户设定浏览器通过缓存进行Web访问。
   - 浏览器向缓存/代理服务器发送所有的HTTP请求
     - 如果缓存中有所请求对象，缓存返回对象。
     - 如果没有，缓存服务器就会向原始服务器发送该HTTP请求，获取对象，返回给客户端并保存该对象。
   - 缓存既充当客户端，也充当服务器。
   - 一般有ISP（Internet服务提供商）架设。

   ![image-20210410205748446](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205748446.png)

   

4. 改善性能的例子

   ![image-20210410205859021](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205859021.png)

   ![image-20210410205925455](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205925455.png)

   ![image-20210410205943164](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205943164.png)

   

5. 如何判别缓存服务器和原始服务器上的对象是否是一致的？

   条件性GET方法：主要思想是如果缓存有最新的版本，则不需要发送请求对象。

   - 缓存：在HTTP请求消息中声明所持有版本的日期 `If-modified-since:< date >`，然后将请求消息发送给原始服务器。
   - 原始服务器：根据时间判断——
     - 如果缓存的版本是最新的，则响应消息中不包含对象，但包含状态码 `304 Not Modifiled`。这样的较空的响应消息是不需要多少带宽的。
     - 如果不是最新的，就将对象放在响应消息中，并包含状态码`200 OK`。
