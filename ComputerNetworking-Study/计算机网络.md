#  计算机网络

## 1、应用层

### 1.1 网络应用的体系结构

> 网络应用的特点，与单机应用的本质性的不同：在网络的两端都会有一些软件或应用程序进行交互。

#### 1.1.1 客户机/服务器结构（Client/Server,C/S）

1. 一个服务器，很多个客户机使用服务，服务器对外提供服务。
2. 服务器
   - 永久性访问地址、域名（不能随意改）
   - 7*24小时提供服务
   - 利用大量服务器实现可扩展性，同时处理大量用户的请求。
3. 客户机
- 与服务器通信
   - 间歇性接入网络，使用时才接入
   - 可能使用动态的IP地址，因为不需要对外提供服务
   - 客户机之间不会直接通信
4. 例子：Web。服务器上运行Web服务器软件，响应请求；常见的客户机就是PC、Mac等，运行着一些浏览器，发送请求。

#### 1.1.2 点对点结构（Peer-to-Peer,P2P）

1. 特点：
   - 没有永远在线的服务器，主机都是平等的
   - 任意端系统/节点之间可以直接通讯
   - 间歇性接入网络（使用时）
   - 可能改变IP地址
   - 例子：文件共享、文件下载

2. 与C/S有什么不同？或者说比较C/S，P2P有什么优缺点？

   - 优点：高度可伸缩。

   - 缺点：实现复杂，难于管理。

#### 1.1.3 混合结构（Hybrid）（前两者混合）

1. 例子：Napster

   - 文件传输使用P2P结构

   - 文件搜索使用C/S结构——集中式。每个节点向中央服务器报告自己的内容（文件名、文件属性等）或者提交查询请求（文件名、文件属性等）。

   > 下图说明：
   >
   > 1. 因为是混合结构，所以需要一个中央服务器；
   > 2. 中央服务器和利用者、提供者构成C/S结构；
   > 3. 利用者和提供者之间直接传输文件构成P2P结构。
   >

   >![image-20210410205049919](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205049919.png)
=======
   > 

思考题：

1. 为每种体系结构找出5种以上的网络应用。
2. 从多个方面/角度对比三种体系结构的优缺点。





###  1.2 网络应用的需求与传输服务

#### 1.2.1 主要需求：

1. 数据丢失（data loss）/可靠性（reliability）

   - 有些网络能够容忍一定的数据丢失：网络电话、视频（表现为视频质量不佳）

   - 相反有些网络要求100%可靠的传输：网上银行

2. 时间(timing)/延迟(delay)
   - 有些应用只有在延迟足够低时才有效
   - 另一种情况：网络电话/网络游戏，比如打电话对方已经说话了，但是过了一分钟才传到己方这边。
   - 当延迟高到一定程度时，可以说这个网络应用实际上已经无效了。

3. 带宽(bandwidth)

   - 某些应用只有在带宽达到最低要求时才“有效”。
     - 比如网络在线看视频，如果带宽比较低的话，视频是很卡的，不连续的。

   - 弹性应用：可以适应任何带宽
     - 比如：email、文件下载（网速快、下得快，网速慢、下的慢，但都能下）

4. 还有一些其他的，比如说安全性的要求。

5. 典型网络应用对传输服务的需求 

   ![image-20210410205143035](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205143035.png)

   

   

#### 1.2.2 Internet（主流网络）提供的传输服务

1. TCP服务
   - 面向连接：客户机/服务器进程间需要建立连接。
   - 可靠的传输：可以将底层的不可靠转化为可靠的。
   - 流量控制：发送方不会发送速度过快，超过接收方的处理能力。
   - 拥塞控制：对整个网络启动的机制，当网络负载过重时能够限制发送方的发送速度。
   - 不提供时间/延迟保障、最小带宽保障

2. UDP服务

   - 无连接
   - 不可靠的数据传输
   - 不提供可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障
   - UDP做的是任何一个传输层服务都必须要做的基本的事情，除此之外都不做。其优点传输过来限制少，使得在应用层可以做很多事情。

3. 典型网络应用所使用的传输层服务

   ![image-20210410205210192](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205210192.png)

   



### 1.3 Web应用

> 万维网（World Wide Web）发明人：Tim Berners-Lee

#### 1.3.1 Web构成

1. Web的构成是一个一个网页，并且网页之间互相连接，从而形成一个庞大的信息网络和内容网络，甚至发展成服务网络。
2. 网页（Web Page）包含多个对象：
   - HTML文件、JPEG图片、视频文件、动态脚本等。
   - 包含基本HTML文件：包含对其他对象引用的链接。
3. 对象的寻址（addressing）
   - Web对象的标识是URL（Uniform Resource Locator），即统一资源定位器。
   - URL基本格式：Scheme://host:port/path（协议://主机的域名或IP地址：端口号/路径）
   - 例子：**www.someshool.edu/**someDept/pic.gif。其中协议被省略，默认为HTTP://，加粗部分是主机名，剩余部分为路径（具体到文件pic.gif）。

#### 1.3.2 HTTP协议概述

> 万维网应用遵循 **超文本传输协议（HyperText Transfer Protocol，HTTP）**。

1. 采用C/S结构

   - 客户——Browser：浏览器，作用是请求、接收、展示Web对象。
   - 服务器——Web Server：响应客户的请求，发送对象。
     - 最典型的WebServer软件是Apache软件，是现在事实上的标准。

2. HTTP版本：

   - 1.0：RFC 1945
   - 1.1：RFC 2068

3. 使用TCP传输服务：流程如下

   - 服务器在 **80端口** 等待客户的请求
   - 浏览器发起到服务器的 **TCP连接**（创建套接字 **Socket**）
   - 服务器接受来自浏览器的TCP连接
   - 浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息（请求和响应消息）
   - **关闭TCP连接**

4. HTTP应用协议是一个**无状态**应用协议，服务器 **不维护** 任何有关客户端过去所发请求的消息（即使是2分钟前）。

   - 一般来说更喜欢使用无状态机制，因为有状态的协议更复杂：

     > 需要维护状态（维护历史信息）；如果客户或服务器失效，会产生状态不一致，解决这种问题代价高。

#### 1.3.3 HTTP连接

> HTTP依靠TCP建立连接。

1. HTTP连接的两种类型

   - 非持久性连接（Nonpersistent HTTP）

     - 每个TCP连接最多允许传输 **一个** 对象，然后就会被关闭。HTTP1.0早期版本使用这种机制。

     

   - 持久性连接（Persistent HTTP）

     - 每个TCP连接允许传输 **多个** 对象，HTTP1.1版本使用这种机制。

   - 两者之间的不同？

2. 非持久性连接（以例子说明）

   - 详细例子

     ![image-20210410205302891](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205302891.png)

       ![image-20210410205401765](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205401765.png)

     

   - 一个非持久性连接的**响应时间分析与建模**

     > RTT(Round Trip Time):**从**客户端**发送**一个很小的数据包**到**服务器并**返回**所经历的时间。

     响应时间(Response time) 分解:

     - 发起、建立TCP连接：1个RTT

     - 发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT

     - 响应消息中所含文件/对象传输时间（完全接收响应消息，包含解析、文件之类的）。

     - 总结：Total = 2RTT+文件发送时间

       ![image-20210410205435540](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205435540.png)

       

   - 特性总结：
     1. 一个TCP连接只允许传输 **一个** 对象，然后就会被关闭。
     2. 一次非持久性连接的响应时间为：Total = 2RTT+文件发送时间。
   - 缺点：
     - 慢：每个对象都需要2个RTT以上的时间才能获得（**串行**）。
     - 操作系统需要为每个TCP连接开销资源（overhead）。

   > 于是就会想可以并行吗？但是就会给服务器端造成很大的负担。TCP连接是一个宝贵资源，都是需要代价的。

3. 持久性连接（改进）

   - 发送响应之后，服务器保持TCP连接的打开状态，后续的HTTP消息可以通过这个连接继续发送。
   - 无流水(pipelining)的持久性连接：
     - 客户端只有收到前一个响应后才发送新的请求。
     - 每个被引用的对象耗时1个RTT。
   - 带有流水机制的持久性连接（HTTP1.1的默认选项）
     - 客户端只要遇到**一个**引用对象就尽快发出请求
     - 理想情况下，收到**所有的**引用对象只需耗时约1个RTT。



#### 1.3.4 HTTP消息格式

1. HTTP协议有两类消息：请求消息（request）、响应消息（response）。都是使用ASCII码，直接可读。

2. 请求消息

   例如：![image-20210410205510933](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205510933.png)

   格式：

   ![image-20210410205626120](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205626120.png)

   

   - 请求消息会携带数据吗？
     - 会，比如说某些请求需要填写用户名信息等，这些被放在 **Entity Body** 消息体中。
   - 那如何上传输入数据呢？
     - POST方法：在请求消息的消息体中上传客户端的输入，然后服务器从消息体获取数据。
     - URL方法：当上传输入的消息较少时，使用GET方法，输入信息通过request行的URL字段上传。
   - HTTP中方法的类型：
     - HTTP/1.0
       - GET方法：从浏览器中获得东西
       - POST方法：向服务器中提交数据
       - HEAD方法：请服务器不要将所请求的对象放入响应消息中。
     - HTTP/1.1
       - PUT：将消息体中的文件上传到URL字段所指定的路径。可以支持向WEB上传文件并保存。
       - DELETE：删除URL字段所指的文件。

3. 响应消息

   例如：

   ![image-20210410205532511](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205532511.png)

   

   - 响应状态码：
     - 200 OK
     - 301 该网页被永久性移走（Moved Permanently）
     - 400 （Bad Request）
     - 404  找不到网页（Not Found）
     - 505 （HTTP Version Not Supported）



#### 1.3.5 Cookie技术

1. 为什么需要Cookie技术

   HTTP协议是无状态的，但是很多应用需要服务器掌握客户端的状态，需要会话状态的，如网上购物。所以需要Cookie技术。

2. Cookie技术的含义

   - Cookie技术是某些网站为了辨别用户身份、进行session跟踪而**储存在用户本地终端上的数据**（通常需要加密）。
   - RFC6265

3. Cookie的组件

   - HTTP响应消息的cookie头部行
   - HTTP请求消息的cookie头部行
   - 保存在客户端主机上的cookie文件，由浏览器管理。
   - web服务器的后台数据

4. Cookie原理

   ![image-20210410205828108](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205828108.png)

   

5. Cookie的作用

   - 身份认证
   - 购物车
   - 推荐……

6. 隐私问题



#### 1.3.6 Web缓存/代理服务器技术

1. 功能

   在不访问服务器的前提下满足客户端的HTTP请求。

2. 性能（即为什么要发明这项技术？）

   - 缩短客户请求的响应时间
   - 减少机构/组织的流量
   - 在大范围网络内实现有效的内容分发

3. 结构

   - 增加一个缓存/代理服务器。用户设定浏览器通过缓存进行Web访问。
   - 浏览器向缓存/代理服务器发送所有的HTTP请求
     - 如果缓存中有所请求对象，缓存返回对象。
     - 如果没有，缓存服务器就会向原始服务器发送该HTTP请求，获取对象，返回给客户端并保存该对象。
   - 缓存既充当客户端，也充当服务器。
   - 一般有ISP（Internet服务提供商）架设。

   ![image-20210410205748446](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205748446.png)

   

4. 改善性能的例子

   ![image-20210410205859021](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205859021.png)

   ![image-20210410205925455](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205925455.png)

   ![image-20210410205943164](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205943164.png)

   

5. 如何判别缓存服务器和原始服务器上的对象是否是一致的？

   条件性GET方法：主要思想是如果缓存有最新的版本，则不需要发送请求对象。

   - 缓存：在HTTP请求消息中声明所持有版本的日期 `If-modified-since:< date >`，然后将请求消息发送给原始服务器。
   - 原始服务器：根据时间判断——
     - 如果缓存的版本是最新的，则响应消息中不包含对象，但包含状态码 `304 Not Modifiled`。这样的较空的响应消息是不需要多少带宽的。
     - 如果不是最新的，就将对象放在响应消息中，并包含状态码`200 OK`。

     

### 1.4 Email应用

#### 1.4.1 Email应用的构成

1. 构成组件

   邮件客户端、邮件服务器、SMTP协议（Simple Mail Transfer Protocol）。

2. 邮件客户端：在Email应用的外围

   - 读、写email信息
   - 与服务器交互，收、发Email消息
   - 例如有Outlook、Foxmail、Thunderbird。
   - Web客户端，使用Web Email时，浏览器也是一个客户端。

3. 邮件服务器：Email应用的核心

   - 邮箱：为每个人创建一个邮箱，存储发给该用户的Email。
   - 消息队列：创建一个消息队列，存储等待发送的Email。服务器会代替客户端将邮件送到指定的地方。

4. SMTP协议（RFC 2821）

   - **邮件服务器之间**传递消息所使用的协议。
     - 客户端：发送消息的服务器。
     - 服务器：接收消息的服务器。

   - 使用TCP进行email消息的可靠传输。

     - 端口为25

   - 传输过程的三个阶段

     - 握手连接 **→** 消息传输 **→** 关闭连接

   - 采用命令/响应交互模式

     > HTTP采用请求/响应交互模式，都是一样的。

     - 命令（command）：ASCII文本
     - 响应（response）：状态代码和语句

   - 特点

     - 使用持久性连接
     - 要求消息必须由7位ASCII码构成
     - SMTP服务器利用CRLF.CRLF（回车换行 **.** 回车换行）确定消息的结束

   - 与HTTP协议的对比

     - HTTP：拉式（pull），客户端需要到服务器把网页拉回到本地。

       SMTP：推式（push），由发送方主动建立连接，把消息推送到接收方。

     - HTTP：每个对象都封装在独立的响应消息中。

       STMP：多个对象在由多个部分构成的消息中发送。

     - 都使用命令/响应 or 请求/响应的交互模式。

       命令和状态代码都是ASCII码。

5. 采用邮件服务器的好处

   我们的手机不能保证7*24小时在线，没办法时刻接收到别人发的邮件；如果不使用邮件服务器，给别人发邮件的时候，一遍发不成功就需要不停地尝试，当对方不在线时，就需要等待，导致电脑不能关闭，这也会导致一个负担。

6. 在最初设计中，Email消息只能包含7位ASCII码。

7. Email应用例子

   - 示例
     
     ![image-20210412081502190](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412081502190.png)
     
     - ①：Alice利用自己的邮箱客户端写了一个消息。
     - ②：她把消息发送给自己的邮件服务器，发送到邮件发送消息队列里去。
  - ③④：Alice的邮件服务器把队列中的消息发送到Bob的邮件服务器。
     - ⑤：消息进入Bob的邮件服务器。
  - ⑥：Bob在某个时刻利用自己的邮件客户端从服务器上获取消息。

   > 结论：email应用是一个异步应用，发送方发送消息和接收方接收消息并不要求同时。

   - SMTP交互示例
   
     ![image-20210412081545292](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412081545292.png)



#### 1.4.2 Email的消息格式与POP3协议

1. Email消息格式

   - SMTP是email消息的传输/交换协议。

   - 文本消息格式标准（RFC 822）

     - 头部行（header）：**1.** To   **2.** From    **3.** Subject   ——与SMTP命令不同
     - 消息体（body）：消息本身，并且只能是ASCII字符。

     ![image-20210412081617055](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412081617055.png)
     
     

2. 如何支持非文本的消息传输呢？

   MIME：多媒体邮件扩展 （RFC 2045,2056）

   - 通过在邮件头部行增加额外的行来声明MIME的内容类型。声明包含：

     - 有多媒体内容
     - 采用什么格式
     - 使用什么方法解码

     ![image-20210412083631313](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412083631313.png)
     
     

3. 邮件访问协议：从服务器获取邮件

   > 由此可看出，一个email应用可以综合的使用多个协议，此点与Web应用不同。

   :one: 邮件访问协议有

   - POP（Post Office Protocol）：认证/授权阶段（客户机和服务器之间，认证一下自己确实是此邮箱的拥有者），从邮件服务器上下载邮件。
   - IMAP（Internet Mail Access Protocol）：更多功能，实现复杂，现常用。
   - HTTP:163,QQ Mail。例如从Web服务器上获取邮件时，就是使用的HTTP协议。

   :two: POP3协议

   - 认证过程：使用命令/响应交互模式。

     客户端命令：User(声明用户名)，Pass(声明密码)。

     服务器响应：+OK(合法用户)，-ERR(用户名或密码不对)。

   - 事务阶段：

     List：列出消息数量

     Retr：用编号获取消息

     Dele：删除消息

     Quit：退出

     ![image-20210412083957551](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412083957551.png)

     

   - **下载并删除**模式

     下载后服务器删除邮件，用户如果更换了客户端软件，无法重读该邮件。

     **下载并保持**模式

     即不删除，不同客户端都可以保留消息的拷贝，但大量的消息都会保存在邮箱里。

   - POP是无状态的

   :three: IMAP协议
   
   - 优点：
     - 所有消息统一保存在一个地方：服务器
     - 允许用户利用文件夹组织消息
     - 支持跨会话的用户状态：可以在服务器上创建文件夹之后，把不同的消息放在不同的文件夹中，所有的客户端上，在此文件夹组织上的消息是一致的。
     - 支持文件搜索……



### 1.5 DNS应用

#### 1.5.1 DNS概述

1. 域名服务（Domain Name System）：解决互联网上主机/路由器的识别问题。

   网络上，主机具有唯一的 **IP地址** ；日常生活中标识主机的是 **域名**，便于人来识别、记忆。

2. DNS服务

   > IP地址和域名如何映射呢？
   >
   > 通过域名解析系统DNS，它能将域名翻译为IP地址。

   :one: 域名向IP地址的翻译

   - 多层命名服务器构成的分布式数据库

   - DNS本身是一个应用层协议，在应用层协议之上有应用层软件负责完成应用层名字的解析。

     - 提供的是互联网的核心功能，但是 是由应用层协议在应用层完成的。

     > 为什么不将DNS放到相对底层呢？应用层不是留给做应用的来发挥的吗？为什么要在应用层来实现呢？效果怎么样？
     >
     > **解答**：
     >
     > 在应用层实现的方式非常符合互联网TCP/IP协议栈的原则的，希望端系统很复杂，但网络核心越简单越好，于是在端系统应用层实现，就可以降低网络核心的的复杂性。

   :two: 提供主机别名、邮件服务器别名。

   :three: 负载均衡：Web服务器。

   - 比如大的门户网站，显然不是一台服务器提供服务，此时打量用户请求可以使用DNS来做负载均衡。当进行域名向IP地址进行翻译时，可以提供多个映射，即Web服务器的IP地址，如果没有新的服务，就将服务器的地址调整一下顺序，这样服务器就可以轮流着来提供服务。

   > 为什么不使用集中式的DNS呢？
   >
   > 如果采用集中式的DNS，会出现以下问题：
   >
   > 1. 单点失败问题：如果使用一台集中式服务器或者多台服务器集中在一起提供服务，一旦这个集中服务点down掉，整个互联网就会瘫痪。
   > 2. 流量问题：几十亿服务主机都到这个点来请求服务，耗费的流量是庞大的。
   > 3. 距离问题：只有一个DNS服务，是不可伸缩的，就会存在距离很远的主机，延迟就会很长，服务性差。

3. DNS的分布式层次式数据库

   > 分布式：分布广泛；层次式：分层。

   ![image-20210412084102237](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084102237.png)

   - 查询IP地址的例子

     当客户想要查询www.amazon.com的IP时，经过如下步骤：

     - 客户端查询根服务器，找到com域名解析服务器。
     - 客户端查询com域名解析服务器，找到amazon.com域名解析服务器。
     - 客户端查询amazon.com域名解析服务器，找到www.amazon.com的IP地址。

     由此可见分布式的DNS也有不足，仅这一个查询就需要进行3次查询才能得到结果。

   - DNS根域名服务器

     > 全球有13个根域名服务器，基本在北美。

     - 本地域名解析服务器无法解析域名时，访问根域名服务器。
     - 根域名服务器解析时，如果不知道映射，访问 **权威域名服务器**，从而获得映射，向本地域名服务器返回映射。

   - 顶级域名服务器（TLD,top-level domain）

     - 负责com，org，net，edu等顶级域名和国家顶级域名，如cn，uk，fr等。

     - 顶级域名服务器需要一些组织来维护

       例如：Network Solutions维护con顶级域名服务器。

   - 权威域名服务器

     - 组织的域名解析服务器，提供组织内部服务器的解析服务。

       > 这个组织比如说大学，有自己的网页、自己的邮箱，对外提供服务，此时就需要提供域名解析服务，将自己内部提供的这些服务的域名与IP地址的映射维护起来。

     - 可以由自己维护，也可以委托服务提供商维护。

   - 本地域名解析服务器

     - 不属于层级体系

     - 每个ISP都有一个本地域名服务器，称为默认解析服务器。

     - 作用：当主机进行DNS查询时，查询会先被发送到本地域名服务器，本地域名服务器作为一个代理，将查询转发给层级式的域名解析服务器系统。

     - DNS查询示例

       ① 迭代查询：被查询服务器返回域名解析器的名字，即“我不认识这个域名，但是你可以访问这个服务器”。

       ![image-20210412084231263](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084231263.png)

       

       ②递归查询：将域名解析的任务交给所联系的服务器，即“我不认识这个域名，然后我直接访问可能知道的下一个服务器，最后再一层一层返回”。

       ![image-20210412084400106](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084400106.png)
       
       两种查询的差别？

4. DNS记录缓存和更新

   - 只要域名解析服务器获得域名-IP映射，就缓存这一映射。但不是无限缓存，一段时间后，缓存条目会失效被删除。
   - 本地域名服务器一般会缓存顶级域名服务器的映射。所以根域名服务器很少被访问。
   - 记录的更新/通知机制：RFC 2136



#### 1.5.2 DNS记录和消息格式

1. DNS记录

   - 也被称为资源记录（RR,resource records）。

   - 格式为：（name，value，type，ttl），一个四元组。

   - 不同type，name和value有不同的解释。

     Type = A ：name——主机域名，value——IP地址。

     Type = NS ：name——域（例如edu.cn），value——该域权威域名解析服务器的主机域名（指出此域的域名解析服务器）

     Type = CNAME ：name——某一真实域名的别名（www.ibm.com），value——真实域名（servereast.backup2.ibm.com）

     Type = MX ：value是和name 相对应的邮件服务器

2. DNS协议与消息

   - DNS协议是查询（query）和回复（reply）模式，并且查询和回复的消息格式是一样的。

   - 消息格式：

     - 头部：举两个例子

       identification：16位查询编码，回复使用相同的编码，这样就能去分开这是为某一个查询提供的回复。

       flags：标志位，标志着是查询或回复、是否期望递归、递归是否可用、是否是权威回答。

       ![image-20210412084435688](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084435688.png)

   > DNS是使用TCP还是UDP？
   >
   > **解答：**
   >
   > DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？
   >
   > DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。
   >
   > - DNS区域传输的时候使用TCP协议：
   >   - 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
   >   - TCP是一种可靠连接，保证了数据的准确性。
   >
   > - 域名解析时使用UDP协议：
   >   - 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

3. 如何注册域名？

   ![image-20210412084658863](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084658863.png)





### 1.6 P2P应用

#### 1.6.1 原理与文件分发

1. 就文件分发而言，P2P 与 C/S 的对比

   **假定：**

   ![image-20210412084720243](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084720243.png)

   -   一个文件服务器，上面有一个大小为F的文件。
   -  有N个结点/主机，接入互联网。
   - 从服务器向n个节点分发这个文件。
   - 假定核心网络有足够的带宽，所以这个性能瓶颈主要在服务器接入网络和节点接入网络。
   - 服务器向网络上传文件，带宽设为u~s~ 。
   - 每个节点从网络上获取文件，设节点i的下载带宽为 d ~i~ 。
   - 在 P2P 模式下，每个节点向其他的节点分享文件块，设节点的上传带宽为u ~i~ 。

   **问题**：从一个服务器向N个节点分发一个文件需要多长时间？

   - C/S模式：

     - 服务器串行的发送N个副本：NF/u~s~
     - 客户机 i 下载：F/d~i~
     - 那么最后的时间应该为 （下载文件最慢的那个客户机需要的时间） 和 （服务器上传N个副本的时间） 之间的最大值。

     > **Total Time = Max {  NF / u~s~  ，F / min(d~i~)   }**
     >
     > 从最后结果来看，当N较大时，时间一般取前者，并且是与N呈线性增长的。

   - P2P模式：

     - 客户机之间可以互相通信，上传或下载片段，所以服务器只需要发送一个副本：F/u~s~
     - 客户机 i 下载：F/d~i~
     - 无论哪种方式，最终都需要下载 NF 比特，每个客户机才能接收到文件。
     - 最快的可能上传的速率为：u~s~ + ∑ u~i~ (即服务器和所有客户机一起上传)。
     - 那么最后时间：Time = Max {  F/u~s~ ,  F / min(d~i~) ,  NF/ (u~s~ + ∑ u~i~)  }

   - C/S vs P2P 直观图

   ![image-20210412084927992](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084927992.png)

   > P2P方式实现文件分发比传统的C/S方式要快。   

2. 例子 BitTorrent

   > 节点上传的速率高，就能找到更好的 “交易伙伴（文件提供方/接收方）”，从而更快地获取文件（成为其他节点的Top4）。

 ![image-20210412085251905](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412085251905.png)

![image-20210412085538087](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412085538087.png)

![image-20210412085548475](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412085548475.png)

#### 1.6.2 索引技术

> 在P2P中经常需要搜索信息。

1. P2P系统的索引：信息到节点位置（IP地址+端口号）的映射。

   例子：

   - 文件共享
     - 利用索引动态跟踪节点所共享的文件的位置
     - 节点需要告诉索引它拥有哪些文件
     - 有需要的节点会搜索索引，从而获知能够从哪里/谁得到哪些文件
   - 即时消息（QQ）
     - 索引负责将用户名映射到位置（比如说IP地址+端口号）
     - 当用户开启IM应用时，需要通知索引它的位置
     - 当发起聊天时，节点就会检索索引，确定用户的IP地址。

2. 索引的设计

   - 集中式索引

     > Napster最早采用这种设计。

     - 有一个中央服务器，当节点加入时，必须告诉中央服务器自己的IP地址和内容。
     - 当一个节点Alice向中央服务器查找 “ Hey Jude” 这个文件时，通过查找，中央服务器会告诉Alice节点Bob有这个文件，然后Alice与Bob通信，获取这个文件。
     - 缺点：虽然内容和文件传输是分布式的，但是内容定位是高度集中式的。就会导致单点失效问题、性能瓶颈、版权问题。

   - 洪泛式（分布式索引）查询（Query flooding）：

     - 完全分布式架构

     - 每个节点只对自己共享的文件进行索引。

       > 那么怎么能够查询所有的文件呢？

     - 覆盖网络（overlay network）：节点X和Y之间如果有TCP连接，那么构成一个边，所有的活动节点和边就构成了覆盖网络。这是一个虚拟网络，边是虚拟链路，节点的邻居一般少于10个。

     - 查询方法就叫做洪泛式查询：

       通过已有的TCP连接发送查询消息给连接上了的节点。

       任何收到查询消息的节点都将转发该查询信息给自己有连接的节点。（所以叫洪泛式查询）

       如果查询命中，则利用反向路径发回查询节点。

     - 缺点：消耗大量带宽，造成网络拥塞；消息泛滥，给网络带来很大负担；节点刚刚加入时，需要的处理比较复杂。

   - 层次式覆盖网络（介于前两者之间）
     - 节点划分为两类：超级节点、普通节点。普通节点之间没有TCP连接，与超级节点之间维护着TCP连接；某些超级节点和超级节点之间会维护TCP。
     - 超级节点负责跟踪子节点的内容，提供索引。
     - 普通节点查询时，会向它的超级节点查询，然后超级节点与超级节点通信进行查询。
     
     ![image-20210412092019809](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412092019809.png)
     
     

3. 案例应用Skype

   ![image-20210412092058455](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412092058455.png)




### 1.7 Socket 编程-应用编程接口（API）

#### 1.7.1 概述

> 1. 网络应用程序实际上是在应用层运行的一些应用进程通信的问题。
>
> 2. 应用进程通信遵循的是应用层协议，其定义了如何交互，交互什么信息。
>
> 3. 而应用进程的交互并不是按照应用层协议将消息直接传送的，而是利用底层传输层，而传输层之下通常是操作系统控制的部分，作为应用层，很多时候是由应用进程控制。
> 4. 当应用进程传输数据的时候，遵循应用层协议，但是真正传输数据的时候，需要把应用进程的数据比如报文处理之后交给相邻层比如说运输层，然后处理之后再交给下一层。
> 5. 因此，作为操作系统之上的应用进程和操作系统之内的网络协议应该如何交互呢？所以需要一个接口，起到连接应用进程和底层协议的桥梁作用。这个接口就是应用编程接口（API）。

1. 应用编程接口API：就是应用进程的控制权和操作系统的控制权进行转换的一个系统调用接口。
2. 几种典型的应用编程接口
   - 套接字（socket）：Berkeley UNIX操作系统定义了一种API。
   - WINSOCK（Windows Socket Interface）：微软公司为其操作系统定义了采用了套接字接口API，形成了一个稍有不同的API。
   - TLI（Transport Layer Interface，传输层接口）：AT&T为其UNIX系统V定义了一种API。

#### 1.7.2 Socket API概述

1. 概述

   - 最初设计
     - 面向BSD UNIX-Berkley
     - 面向TCP/IP协议栈接口

   - 套接字是Internet网络应用最典型的API接口

   - 绝大多数操作系统都支持

   - 通信模型：客户/服务器（C/S，最基础）

   - 提供了应用进程间通信的抽象机制

     例如客户应用进程和服务器应用进程要通信，都各自要创建套接字（注意服务器应用进程是要先运行的，客户应用进程时候运行的、主动通信的），就像服务器的套接字是插座、客户应用进程的套接字是插头。

     ![image-20210419082124412](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082124412.png)

2. 套接字的管理机制

   - 对外：比如我们的应用进程，针对我们的客户端来看，客户端想要说明自己要与哪一个服务器进程的端口进行通信，只需给出IP地址+端口号。

     标识套接字：**IP地址+端口号**

     > **问题引入**：应用层有很多服务器应用进程，各自提供不同的功能，为了能和客户进程通信，都要创建套接字，一个进程通常来说会创建多个套接字，不同进程会创建自己的套接字。那么一个客户应用进程如何选择和哪一个服务器应用进程通信呢？（插头插在哪一个插座上？）
     >
     > **分析**：
     >
     > 1.  通过IP地址，但只通过IP地址确定不够，因为每个服务器进程可能会创建多个套接字。
     > 2. 无论是客户端应用进程还是服务端应用进程，它们的通信过程都是与它相邻的传输层的协议进行交互，这也是套接字的作用。
     > 3. 这些套接字事实上都是会与底层的传输层协议进行信息的交换，应用层的数据要通过底层的接口交给传输层协议，传输层协议收到的数据要通过套接字接口交给响应的应用进程。
     > 4. 从传输层的协议角度来看，这些套接字就相当于是连接在传输层协议上的一个个端口，传输层协议为了明确区分每一个端口，引入了一个机制，即 给每个套接字绑定一个**端口号** 。
     >
     > **结论**：最后，IP地址可以确定是位于哪一个主机上的运行的某一个进程的套接字，端口号可以确定是哪一个套接字。
     >
     > ![image-20210419082203122](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082203122.png)

   - 对内：操作系统管理套接字

     使用的是套接字描述符（socket descriptor）,一个进程在创建一个套接字的时候就会返回一个套接字描述符。这个操作系统在管理这个操作系统内的进程所创建的所有套接字的时候，都是通过套接字描述符进行管理。

3. Socket抽象

   - 作为套接字，在使用套接字描述符进行管理实际上是一种抽象机制，非常类似于文件的抽象

     例如：UNIX操作系统事实上把套接字和文件统一管理，将套接字视为特殊的文件。

   - 当应用进程创建套接字时，操作系统分配一个数据结构存储该套接字相关信息。

   - 创建套接字时会返回套接字描述符。

     ![image-20210419082235584](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082235584.png)

     在操作系统中，每一个进程都会管理一个存储socket描述符的表，每创建一个套接字，就会在表中存储对应的描述符，类似于一个入口，每个入口有一个指针指向存储对应套接字信息的套接字数据结构。

4. 套接字地址结构

   > 套接字信息：包含IP地址、端口号等信息，其中最重要的是端点地址信息，即IP地址+端口号。

   在套接字API中定义了地址结构 sockaddr_in，在声明端点地址变量时，使用结构 sockaddr_in。

   ![image-20210419082303998](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082303998.png)



#### 1.7.3 Socket API 函数(WinSock 为例)

1. 函数名一般以“WSA(WinSock API)”开头。

2. Windows的网络应用程序最开始调用的是“WASAStartup”，最后要调用的是“WSACleanup”。

   原因：WinSock的实现机制是以Windows操作系统的动态链接库实现的，所以最开始要初始化动态链接库，最后要释放动态链接库。

   ![image-20210419082323626](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082323626.png) 

3. WSAStartup 函数

   ![image-20210419082405766](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082405766.png)

4. WSACleanup 函数

   ![image-20210419082424533](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082424533.png)

5. Socket函数

   ![image-20210419082450271](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082450271.png)

   ![image-20210419082514674](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082514674.png)

6. Closesocket 函数

   - 声明：`int closesocket(SOCKET sd);`

   - 作用：关闭一个描述符为 sd 的套接字，对于TCP连接还会关闭连接。

   - 共享套接字的关闭问题：

     - 多进程共享一个套接字：

        使用计数方法，每次调用closesocket将套接字的引用计数减1，减至0才关闭。

     - 一个进程的多个线程共享一个套接字：

       无需计数，因为当其中一个线程调用closesocket将套接字关闭时，该进程中的其他线程也无法访问了，即套接字被关闭了。

   - 返回值：

     - 0：成功
     - SOCKET_ERROR：失败

7. bind函数

   - 声明：`int bind(sd,localaddr,addrlen);`

   - 作用：绑定套接字的本地端点地址。（因为套接字最初在创建的时候没有端点地址。）

   - 参数：

     - sd：套接字描述符。
     - localaddr：端点地址。其结构应该是sockaddr_in。
     - addrlen：地址的长度。

   - 客户程序一般不必显示调用 bind 函数。

     因为操作系统会设置套接字的本地的端口号和IP地址。

   - 服务器端需要调用 bind 函数来指定服务器端的熟知端口号。

     比如说我们是一个标准应用，那么，如果是要创建web服务器熟知端口号就是80，默认的SMTP是25，以此类推。

   - 问题：那么IP地址该如何绑定呢？直接绑定服务器运行的主机的IP地址吗？

     > **假设**：主机通过两个网络接口，分别连接在两个网络上，这两个网络有IP地址1和IP地址2，如果在这个主机上运行一个服务器，那么应该绑定哪一个呢？
     >
     > **分析**：如果绑定任意一个IP地址，那么从另外一个IP地址来的服务请求就无法提供服务。
     >
     > **解决**：定义一个地址通配符——INADDR_ANY，其意味着在运行服务器的主机上的任意一个IP地址都是可以的。

     所以服务器端在调用bind函数时，除了绑定端点地址设定一个端口号之外，还要将IP地址赋值为INADDR_ANY。

8. listen 函数

   > 1. 套接字在最开始创建的时候，事实上客户端和服务器端的套接字并没有严格的区别。
   > 2. 但基于套接字这样的机制下，我们的网络应用程序都是采取C/S模式。
   > 3. 作为服务器端套接字，如果需要作为服务器进行通信的话，那么就需要吧服务器端的套接字置为一种被动监听的状态。
   > 4. 这个工作就可以由listen函数完成。

   - 声明：`int listen(sd,queuesize);`

   - 作用：置服务器端的流套接字处于监听状态。

   - 范围：仅服务器端调用；仅用于面向连接的流套接字。

   - listen函数为流套接字设置了连续请求队列的大小。

     设置这个大小的作用：当有很多请求到达的时候就放在这缓存队列里面进行缓存，服务器就会从这个队列里面一一提取，这个队列是先进先出的。

   - 返回值：

     - 0：成功
     - SOCKET_ERROR：失败

9. connect 函数

   - 声明：`connect(sd,saddr,saddrlen);`

   - 作用：客户程序调用connect函数来使客户套接字（sd）与特定计算机的特定端口（saddr）的套接字（服务）进行连接。

   - 范围：仅用于客户端。但既可以用于TCP客户端，也可以用于UDP客户端。

     - 当用于TCP客户端时：会建立TCP连接，就可以与服务器端进行通信了。

       ![image-20210419082558453](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082558453.png)

     - 当用于UDP客户端时：只会指定服务器端点地址，在调用其他函数时，就像已经连接了一样，但实际上并未建立连接，所以不一定能和服务器端通信。

   - 参数：

     - sd：客户端的套接字
     - saddr：远程套接字的端点地址，指定服务器的套接字。
     - saddrlen：地址长度。

10. accept 函数

    > 作为服务器端，一个套接字创建成功，绑定了端点地址，服务器一般绑定了INADDR_ANY，指定了一个熟知端口号，然后调用listen处于一种被动的监听模式，指定一个队列大小，接下去服务器端的TCP套接字就需要调用accept这个函数，这个函数也是一个阻塞函数。

    - 声明：`newsock = accept(sd,caddr,caddrlen);`

    - 范围：只用于服务器端、TCP套接字。

    - 参数：

      - sd：服务器端最初创建的tcp套接字
      - caddr：客户端发送过来的连接请求的客户端端点地址。

    - 作用：服务器端调用accept函数从处于监听状态的流套接字sd的客户连接请求队列中取出排在最前的一个客户请求，并且创建一个新的套接字，使用该新的套接字与该客户通信并且其提供服务。

      ![image-20210419082626905](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082626905.png)

      > 为什么要创建的新的套接字呢？
      >
      > 因为TCP连接是点对点的，只能用于连接两者，如果使用服务器端的主套接字与之连接，那么此服务器就只能为这一个客户提供服务，就不能够实现并发的TCP服务器。

11. send,sendto函数

    - 声明：`send(sd,*buf,len,flags);`	`sendto(sd,*buf,len,flags,destaddr,addrlen);`

    - 作用：用来发送数据的。

    - 区别：

      - send并没有指定数据发送的端点地址。所以TCP的套接字，不管是客户端还是服务器端，因为已经有连接了，所以使用send发送数据。但也可以用于UDP客户端的套接字，前提是调用了connect函数。

        > 有时候会把调用了connect函数的UDP客户端的套接字称为连接模式的UDP套接字。

      - sendto :用于没有连接或者说无连接模式的UDP套接字，比如说UDP服务端的套接字或者说未调用connect函数的UDP客户端套接字来发送数据。

12. recv,recvfrom函数

    - 声明：`recv(sd,*buffer,len,flags);` `recvfrom(sd,*buf,len,flags,senderaddr,saddrlen);`
    - 作用：用来接收数据。
    - 区别：
      - recv：没有指定从哪一个服务器接收数据，所以可以用于从TCP连接的另一端接收数据，或者从调用了connect函数的UDP客户端套接字接收服务器发来的数据。
      - recvfrom：用于无连接模式的UDP套接字，比如说UDP服务器套接字和未调用connect函数的UDP客户端的套接字。
    
13. setsockopt,getsockopt函数

    - 声明：`int setsockopt(int sd,int level,int optname,*optval,int optlen);` 

      ​            `int getsockopt(int sd,int level,int optname,*optval,socklen_t *optlen);`

    - setsockopt()函数用来设置套接字sd的选项参数。

      getsockopt()函数用来获取任意类型、任意状态套接口的选项当前值，并把结果存入optval。

14. 函数总结：WSAStartup 、WSACleanup：只用于winsock中。

15. 网络字节顺序（networking byte order）

    > 在OS参考模型中有七层：从下到上是物理层、数据电路层、网络层、传输层、会话层、表示层、应用层，其中表示层解决的是数据表示转换的问题，实际上它的功能是，比如说当两个系统之间通信的时候，比如说客服端和服务器之间通信的时候，那么两个系统的数据表示不一样的时候，那么表示层就要将其转换为标准的表示形式，然后到达本地在转换为本地形式。
    >
    > 但在五层网络模型中并没有表示层，那么这个部分的工作怎么完成呢？

    - TCP/IP定义了标准的独立于操作系统的网络字节顺序，也就是说用于协议头中的二进制整数都用网络字节来存储。

    - 因此某些socket API函数的参数都需要存储为网络字节顺序，比如IP地址、端口号等，如果是存储为本地字节顺序，如果与网络字节顺序不一致，就会出错。

    - 在编程时注意本地字节顺序和网络字节顺序的转换，下面有一些相关的转换函数：

      - htons：本地字节顺序 → 网络字节顺序（16bits）
      - ntohs：网络字节顺序 → 本地字节顺序（16bits）
      - htonl：本地字节顺序 → 网络字节顺序（32bits）
      - ntohl：网络字节顺序 → 本地字节顺序（32bits）

    - 网络应用的socket API(TCP)调用流程

      ![image-20210419082708718](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082708718.png)



#### 1.7.4 客户端编程



#### 1.7.5 服务器端编程



## 2、传输层

### 2.1 传输层服务

#### 2.1.1 学习内容

1. 传输层服务的基本理论和基本机制
   - 多路复用/分用
   - 可靠数据传输机制
   - 流量控制机制
   - 拥塞控制机制
2. internet的传输层协议
   - UDP：无连接传输服务
   - TCP：面向连接的传输服务
   - TCP拥塞控制

#### 2.1.2 传输层服务概述

1. 传输层服务和协议

   - 功能:传输层协议为运行在不同主机上的进行提供了一种 **逻辑通信机制**。

   - 逻辑通信机制：
     - 两个进程之间仿佛是直接连接的，不关心这之间经过了多远的物理距离、多少个路由器、中间使用了什么媒介。
     - 是两个端系统，端到端的，直接提供的连接。
   - 端系统上运行的传输层协议的工作方式：
     - 发送方：将应用递交的消息分解成一个或多个报文段（segment），然后交给网络层，由网络层将其发出去。
     - 接收方：从网络层接收到报文段，把一个或多个报文段组装起来，成为消息，然后交给应用层。
   - 任何一个网络包括Internet都是可以提供多种传输层协议和传输层服务。
     - 例如TCP、UDP。

2. 传输层和网络层之间的区别

   - 网络层：同样是提供逻辑通信机制，但是他提供的是主机之间的。

   - 传输层：提供应用进程之间的逻辑通信机制；位于网络层之上并且依赖于网络层服务；对网络层服务进行可能的增强。

   - 传输层提供的最基本的一个功能是多路复用和多路分用。

   - 两者关系类比：

     李雷和韩梅梅两家各有12个孩子，12个李家孩子和12个韩家孩子要互相送信，这时候让李雷和韩梅梅分别负责从自己家中的孩子收集信并送到邮政或者从邮政取信送回给每个孩子。那么

     > 孩子 → 应用进程；信 → 应用消息；房子 → 主机；李雷和韩梅梅 → 传输层协议；邮政服务 → 网络层协议。

3. Internet 传输层协议

   - TCP：可靠的（数据报文不会丢失）、按序（按照发送的顺序到达）的交付服务
     - TCP中有拥塞控制、流量控制、连接建立，这些就是保证可靠和按序的重要条件。
   - UDP：不可靠的交付服务。
     - 基本上是直接基于网络层的服务。
     - “尽力而为”，不保证传输过程中一定传达或者不丢失。
     - 只是实现了传输层上的一些必要的服务，比如说多路复用或者分用。
   - 两种服务都不提供延迟和带宽方面的服务。





### 2.2 复用和分用

#### 2.2.1 多路复用和多路分用

1. 为什么要进行多路复用/多路分用？

   如果网络协议栈的某层对用直接上层的多个协议或实体，就需要复用或分用。

   > 主机2的传输层作为接收端，就必须进行多路分用，因为下面的网络层协议只有一个，当传输层从网络层接收到报文之后，必须要做的事情是把所接受的报文段正确的交给进程，也就是说从p3来的正确的交给p1，从p4来的正确的交给p2。这个功能就叫做多路分用。
   >
   > ![image-20210419082744355](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082744355.png)

2. 如何多路复用/多路分用

   - 接收端进行 **多路分用**：传输层依据头部信息将收到的报文段交给正确的socket，即不同的进程。
   - 发送端进行 **多路复用**：网络层只有一个，发送端从多个 socket 接收数据，为每一块数据封装上正确的头部信息，生成报文段，交给网络层发送。

3. 多路分用如何工作？

   - 主机接收到IP数据包（datagram）

     - 每个数据包携带源IP地址、目的IP地址。
     - 为了能够分用，每个数据包还会携带一个传输层的段。
     - 每个段会携带源端口号和目的端口号。

     ![image-20210419083258565](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083258565.png)

   - 主机收到报文段之后，传输层协议提取IP地址和端口号信息，将报文段导向相应的socket，即交给对应的进程。

     > 1. 在收到socket之后，TCP会做更多的处理。
     > 2. 在此过程中，网络层并不关心IP地址和端口号。

4. 无连接的分用（面向UDP）

   - 利用端口号创建Socket

     ```java
     //利用端口号99111创建UDP数据包的socket。利用端口号99222创建了另外一个socket。
     DatagramSocket mySocket1 = new DatagramSocket(99111);
     DatagramSocket mySocket2 = new DatagramSocket(99222);
     ```

   - 对于无连接UDP的Socket使用二元组来标识的，也就是（目的IP地址,目的端口号）。

     - 如上，创建的socket就会被主机的IP地址和自定义的端口号标识。

   - 主机收到UDP段后

     - 检查段中的目的端口号
     - 将UDP段导向绑定在该端口号的Socket，也就是进程。

   - 来自不同源IP地址，也就是不同的主机，或者不同源端口号的IP数据包，只要目的IP地址和目的端口号一样，就会被导向同一个socket。

   - 例子：

     ![image-20210419082810082](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419082810082.png)

5. 面向连接的分用（面向TCP）

   - TCP的socket是用四元组来标识的，也就是：源IP地址，源端口号，目的IP地址，目的端口号。

   - 接收端利用所有的四个值（上述四元组）将报文段导向合适socket。

   - 服务器因为会给很多客户提供服务，所以会创建多个进程，相应的创建多个TCP的socket，每个socket都有自己的四元组进行标识。

     比如，Web服务器就会为每个客户端开不同的Socket。

     ![image-20210419083331574](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083331574.png)

     ![image-20210419083400375](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083400375.png)
     
     > 问题：为什么只有一个P4进程，也能维持多个TCP连接，给多个客户端应用进程提供服务呢？
     >
     > 由于进程是一个耗费资源比较多的一种机制，所以现在可以让一个进程创建多个线程这样轻量级的机制，把它们和不同的TCP连接绑定在一起，通过不同的线程维持多个TCP连接，为客户端提供服务。



### 2.3 UDP协议（User Datagram Protocol）

#### 2.3.1 UDP

1. 基于 Internet IP协议

   - 增加了多路复用/分用。

   - 增加了一个简单的错误校验机制。增加了一个校验和，在发送方会计算这个校验和，在接收方会重新计算这个校验和，从而比对判断这个报文段在整个发送过程当中是否有错误的发生。

     > 链路层应该会做错误检测啊，为什么要在传输层做错误检测呢？
     >
     > 强调端到端的原则：
     >
     > 1. 传输层提供的是端到端的逻辑通信服务，在此过程中可能经过多个路由器，可能使用不同的物理媒介和不同链路的协议，但并不能确保所使用的所有的链路层协议都有错误检测和恢复的机制。
     >
     > 2. 即使过程中链路层都有错误检测和恢复机制，但在路由器存储转发的过程中也有可能出错。所以需要在离应用层最近的一层传输层增加这个错误检测机制。

   UDP除了这两件事之外就没做什么了，所以基本上是将IP层服务暴露给了应用层，这是UDP的一个特点。

2. UDP提供的服务模型

   - “尽力而为”的模型，因为本身IP层就是一个尽力而为的服务模型，虽然UDP有一个简单的错误校验，但也没有错误恢复，所以IP层是不可靠的（Best effort），所以UDP也是不可靠的。
   - UDP的报文段可能会丢失，也可能会非按序到达。

3. 无连接

   - UDP本身是一个数据报的协议，无连接的。
   - 发送方和接收方不需要握手，不需要连接。
   - 问题：每个UDP报文段的处理都独立于其他报文段。

4. UDP为什么存在？

   - 因为UDP不需要连接，所以在发送前的延迟显著减少。  所以DNS用的是UDP而不是TCP。
   - UDP的实现简单，没有连接，不需要维护连接的状态。
   - 头部开销更少，TCP头部20个字节，UDP8个字节。
   - 因为UDP没有拥塞控制，在使用UDP时，上层应用可以更好的地控制发送时间和速率。而TCP有拥塞控制，当使用TCP时，TCP会根据拥塞控制去调节速率，不100%地听命于上层应用。

5. UDP的用途

   - 用于流媒体的应用，因为它可以容忍一定的数据包的丢失，特点是速率敏感，要求比较高。
   - 用于DNS，SNMP。

6. 如何在UDP之上实现可靠数据传输？

   - 可以在应用层增加可靠性机制以及应用特定的错误恢复机制。
   - 此时应用的开发难度比较大。

7. UDP报文段格式

   ![image-20210419083435416](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083435416.png)

8. UDP的校验和（checksum）

   - 目的：检验UDP端在传输过程中是否发生错误（比如发生0→1的位翻转）。

   - 怎么做？

     - 发送方：

       :one: 将段的内容视为16bit的整数，然后计算所有整数的和，最高位的进位单独拿出来和剩余的位组成的和相加，将得到的和按位求反，得到校验和。

       :two: 然后将校验和填充到UDP段的校验和字段里面被发送。

     - 接收方：

       :one: 计算搜收到段的校验和，和发送方计算的方式一致。

       :two: 将计算结果和校验和字段进行比对，如果

       - 不相等：UDP段有错，传输过程中发生了错误。
       - 相等：没有检测出错误，但有可能有错误。比如有两个位发生翻转。

   - 问题：校验和只能检验出某些错误。

   - 校验和计算例子：

     ![image-20210419083543348](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083543348.png)



### 2.4 可靠的数据传输的基本原理

#### 2.4.1 可靠数据传输原理

> 现实世界中，很多信道本质上是不可靠的，可能在传输过程中会发生位错误，又可能会丢包，比如说由于路由器的缓存溢出，发生丢包。所以在计算机网络世界里，就有一个普适性的问题：如何把不可靠的信道转变为可靠的信道实现可靠数据的传输？

1. 什么是可靠？

   计算机网络中的可靠：

   - 不错：分组在传输过程中有一位从0变成1，发生错误。
   - 不丢：分组丢了。
   - 不乱：分组的顺序不乱，并且一个已经被收到的分组再次被收到要能辨认出这是一个已经被收到过的分组。

2. 可靠数据传输依靠的是可靠数据传输协议（rdt）

   - 可靠数据传输对应用层、传输层、链路层都很重要。UDP本身提供的是不可靠的，如果应用有需要实现可靠，那么就必须在应用层实现可靠数据传输协议。

   - 可靠数据传输被列为前十大网络问题之一。

   - 信道的不可靠特性决定了可靠数据传输协议的复杂性，所以在研究可靠数据的传输的时候，就要清楚信道的哪些特性导致了不可靠。

   -  图解

     ![image-20210419083610241](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083610241.png)

     - 从所提供的服务的角度看，红线上是应用层，在接收方是一个接收进程，在发送方是一个发送进程。红线下是传输层，传输层为应用层提供的可靠数据传输服务，从这个角度看就是提供的一个可靠的信道。既然是可靠的信道，那么发送进程就可以将数据交给这个可靠的信道，数据就能被可靠的发送到接收方那一端，然后接收端提取出来。
     
     - 从服务的实现来看，底层是一个不可靠信道，可靠数据传输协议在传输层，在发送方有可靠数据传输协议部分，在接收端也有可靠数据传输部分，这两个部分相互配合共同实现数据的可靠传输。发送进程向下调用或者依赖的是不可靠的信道，会将分组交给下面这个不可靠的信道，这时候就会调用 `udt_send()`，不可靠的；到接收方这一端，会调用 `rdt_rcv()`表示收到分组，然后发送方这一端上层应用会调用 `rdt_send()` 把数据交给可靠数据传输协议，从提供服务的角度来看，上层看到的传输层提供的是可靠的数据传输。在接收方这一端向上层应用提供的正确的数据交互。那么整体概括来看就是一个可靠的数据传输。

3. 可靠数据传输协议基本结构：接口

   ![image-20210419083634620](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083634620.png)

   > 单向：
   >
   > 1. 上层网络应用调用 `rdt_send()`，并且单向地调用传输层可靠数据传输协议之后，其他的就都交给传输层了。
   >
   > 2. 底层的可靠数据传输协议把所有的事情都做好之后，才把数据正确地交付给网络应用，应用层不关心数据的丢失和错误，这都是有传输层来处理的。
   >
   > 双向：
   >
   > 1. 可靠数据传输协议（传输层）和不可靠的信道（网络层）的调用都是双向的。意味着在不可靠的信道上面实现可靠数据传输并不是一个简单的单向的数据流动，需要双向的控制数据的流动。

4. 可靠数据传输的协议

   > 网络协议是双方的，发送方和接收方都要有，而且他们之间一定是要配合的。
   >
   > 假设在研究可靠数据传输协议的过程中只考虑单向的数据流动。比如说发送方要把数据发送给接收方。
   >
   > 数据是单向流动的，但是控制信息是双向流动的。

   - 利用有限状态自动机（FSM）刻画传输协议

     ![image-20210419083656508](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083656508.png)

   - rdt 1.0：可靠信道上的可靠数据传输协议

     - 底层信道完全可靠：不会发生错误（位错误），不会发生丢失、乱序。（理想状态）。

     - 发送方和接收方之间不需要控制信息的交换，因为是可靠信道，发送方只需要发送出去，就会正确无误地被送到接收方，两者不需要有更多的交互。

     - 发送方和接收方的FSM是的独立的。

       ![image-20210419083816930](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419083816930.png)

       :one:发送方

       - 只有一个状态——等待上层调用，例如应用层的调用。
       - 当有上层调用的时候，产生事件 `rdt_send(data)`函数调用，这个`data`就是上层交给发送方去交付的数据。
       - 当发生这个事件时，需要采取一些活动：
         1. `make_pkt(data)`创建分组，创建一些packet。
         2. 然后调用信道上的`udt_sent(packet)`，把数据发出去。
         3. 发出去之后，由于发送方确信这个分组可以100%的被正确地交付，所发送方又会回到这个状态，继续等待上层的调用。

       :two:接收方：

       - 也只有一个状态——等待下层的调用。这个调动也就是`rdt_rcv(packet)`这个事件，穿过来一个分组。
       - 当这个事件发生时，就会进行一个提取操作，从分组当中把这个数据提取出来，因为是可靠信道，收到的100%是正确的，无需检测错误。
       - 然后向上层交付，最后回到等待下层调用的这个状态。

#### 2.4.2 Rdt 2.0(针对不可靠信道)

1. 产生位错误的信道

   - bit error：底层信道可能会把分组中的某个0翻转为1，把某个1翻转为0。

     > rdt2.0中界定研究的信道只会产生位错误，不会发生丢失或乱序。

   - 不可靠信道在可靠传输协议中存在的问题：

     - 接收方需要知道收到的分组是否有错，如果错了，是不是要重传呢？但自己只有错误的分组，是无法恢复正确的分组的，所以就可能需要与发送方合作恢复这个分组。

   - 那我们怎么检验出这种错误呢？

     利用校验和检测为错误。

   - 那么又如何从错误中恢复过来呢？（ACK/NAK机制，重传机制）

     > 考虑发送方是否知道分组是正确到达还是发生了错误呢？
     >
     > 发送方自己是不会知道的，这需要接收方给出一个显式的消息来告诉发送方这一点。

     - 确认机制（Acknowledgements,ACK）：接收方显示地告知发送方分组已正确接收。

     - NAK（Negative）：接收方显式的告知发送方分组有错误。

       发送方收到NAK后，重传分组。

   - 基于这种重传机制的rdt协议，又被称为ARQ（Automatic Repeat Request）协议。

2. rdt2.0 VS rdt 1.0

   因为不可靠的信道，rdt2.0 多了

   - 差错检测机制——校验和
   - 接收方反馈控制消息：ACK/NAK
   - 重传机制

3. rdt2.0 的设计：FSM规约（有限状态自动机）

   ![image-20210419105307541](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419105307541.png)

   - 发送方：

     1. 两个状态：等待上层调用，等待ACK/NAK（发完之后等待对方发送的控制消息）。

        > 这样的协议叫做停-等协议，即发送一个分组之后需要一直等待响应。

     2. 工作：

        - 当处于等待上层调用的状态时，上层应用给了一个调用，发送方就会产生一个packet，注意此时packet需要包含一个校验和（checksum），然后调用udt_send发送。然后进入等待ACK/NAK的状态。
        - 当处于等待ACK/NAK状态的时候，收到来自接收方反馈的控制消息，并且判断出是一个NAK，就要调用udt_send重发分组。然后仍然是等待ACK/NAK状态，直到收到ACK的控制消息，然后返回等待上层调用的状态，此时的状态变迁一旦被触发不需要进行任何操作，直接转换状态，所以可以看到图中框起来的部分横线下面的 “^”符号，表示action是空的。

   - 接收方

     1. 一个状态：等待下层的调用。
     2. 工作：
        - 当下层有数据传过来的时候，接收方会收到一个packet，然后去判断收到的分组是否有错误。如果有错误，调用udt_send返回一个NAK分组给发送方。
        - 如果没有错误，就从分组中提取数据，向上层交付，并且发送一个ACK给发送方。

   - 几个场景

     - 无错误场景

       分组在信道传输过程中没发生错误。

       ①发送方处于等待上层调用，接收方处于等待下层调用。

       ②发送方收到调用，计算校验和，产生分组，发送分组，并转换到等待ACK/NAK状态。

       ③分组到达(rdt_rcv(rcvpkt))，并且无错误，执行下面的操作。

       ![image-20210419105906989](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419105906989.png)

       ④发送方接收到ACK，返回到等待上层调用状态。

     - 有错误场景

       与上面不同的是③，此时接收方执行上面的操作。然后发送方会重传分组。最终以无错误的场景结束。

       ![image-20210419110018821](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419110018821.png)

#### 2.4.3 Rdt 2.1和2.2

1. Rdt2.0的缺陷

   如果NAK/ACK消息从接收方传输到发送方发生错误/被破坏会怎么样？Rdt2.0对于这个错误并没有给出定义，那么可能就处理不了了。所以需要改进

2. 解决方法

   - 为**ACK/NAK增加校验和**，检错并纠错。但是难度较大。
   - 发送方收到错误的ACK/NAK时无法检测出接收方发生了什么，那么此时可以**添加额外的控制消息**，比如说发送方再发送给接收方一个消息“你刚刚说的什么？”。但这种方法不能从根本上解决这个问题，因为额外的控制消息在传输过程中仍然可能发生错误。
   - 如果ACK/NAK错误：**发送方直接重传**。那么会导致接收方收到重复的分组。所以需要引入一个新的机制。
     - 增加序列号。发送方给每个分组增加序列号，如果重复，接收方直接丢弃。

3. rdt 2.1 

   - 在rdt2.0的版本之上增加了序列号

   - 有限状态机的描述：

     - 发送方：

       引入两个序列号 0 和 1，含有四个状态：等待上层的调用并且分组序列号是0，等待序列号为0的ACK/NAK；剩下的两个状态对应于序列号为1。

       ![image-20210419113252787](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419113252787.png)

     - 接收方：

       两个状态，因为他需要接受到序列号为0、1的两个分组。

       ![image-20210419113310143](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419113310143.png)

       问题：在图中标上问号的情况中，为什么接收方必须发送一个ACK，而不是发送NAK或者置之不理呢？

   - rdt 2.1 VS rdt 2.0

     - 发送方：

       1. 为每个分组增加了序列号，并且两个序列号0、1就够用了。

          因为rdt2.1协议采用的是停-等协议。

       2. 需要校验ACK/NAK消息是否发生错误

          因此接收方传回的控制消息也需要加上校验和。

       3. 状态数量翻倍

          因为状态需要记住当前分组的序列号。

     - 接收方：

       1. 需要判断分组是否是重复的。

          当前状态会提供期待收到分组的序列号。

4. rdt 2.2

   - 问题引入：是否需要两种确认消息呢？因为确认消息越多，程序处理的逻辑也会越复杂。可能取消掉一个确认消息吗？

     可以取消掉NAK。

   - 如何实现只使用ACK？

     - 接收方通过ACK告知最后一个被正确接收的分组。

       也就是说，如果某次接收到的分组是正确的，但是序列号不是所期待的，此时会返回一个含所接收分组的序列号的ACK；当下一次重传的分组发生错误的时候，接收方也会重发ACK，而这个ACK就是上次的ACK。这也就是下图箭头的含义。

     - 在ACK消息中显式的加入被确认分组的序列号，解决重复分组的问题。

     - 发送方收到重复的ACK之后，会重传当前的分组。

     ![image-20210419114913548](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419114913548.png)

     



#### 2.4.4 Rdt 3.0

1. 问题引入：在rdt2.x的时代，只考虑了位错误的情况，那么如果也有可能发生分组丢失怎么办？依然采取“校验和+序列号+ACK+重传”可行吗？

   > 考虑如下两种情况：
   >
   > 1. 发送方发送的分组丢失，这会导致发送方一直处于等待控制消息的状态，而接收方什么都不会做。
   > 2. 接收方传回的控制消息ACK/NAK丢失，那么发送方依然会一直等待下去。
   >
   > 这两种情况都会导致协议失效。所以rdt2.x是无法处理丢失问题的。

2. 解决方法：

   - **设置发送方的“合理”的等待时间。**

     - 等待合理的时间之后，如果没收到ACK，那么重传分组。

     - 但“合理”的时间的设定是比较困难的。

       比如说分组或ACK只是延迟而不是丢失，在合理时间之后才会到达。会导致重复的问题，不过序列号机制已经解决这个问题了。

   - **增加定时器**。

3. rdt 3.0 发送方的FSM

   ![image-20210419144531046](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419144531046.png)

   问题：考虑此时接收方发生了什么变化？

4. rdt 3.0可以解决的典型场景

   ![image-20210419152718967](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419152718967.png)

   ![image-20210419152742475](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419152742475.png)

   

   > rdt3.0中计时器的设置是一个问题。

5. rdt 3.0的性能分析

   > rdt3.0虽然可以正确工作，但是它的性能很差，特别是在链路带宽速率很高的时候。

   - 示例：

     ![image-20210419155414180](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419155414180.png)

     PS：因为rdt3.0是一个停-等协议，而端到端的传播延迟是15ms，那么RTT是传输的一个来回，所以约为30ms。

     > 说明：
     >
     > 1. rdt3.0的性能很差。
     >
     > 2. 当设计不好的时候，网络协议是有可能限制物理资源、硬件资源的利用。所以常常协议是软硬件的协同设计。

   - 产生性能差的根本原因就在于停等操作。

     ![image-20210419155435623](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419155435623.png)

   

   

  ### 2.5 滑动窗口协议

#### 2.5.1 流水线机制与滑动窗口协议

1. 引入：rdt3.0性能差的原因就是停等协议，为了提高性能，就需要打破停等协议，在等待的时候也可以发送其他分组。于是提出流水线机制和滑动窗口协议。

2. 针对上一节的例子，给出下面对应流水线机制的例子：允许三个分组一起发送，那么利用率就可以提高三倍。

   ![image-20210419163127056](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419163127056.png)

   **结论**：流水线机制可以显著提高网络资源的利用率。

3. 流水线协议

   - 需要允许发送方收到ACK之前连续发送多个分组。那么就需要

     - 更大的序列号范围

     - 发送方和/或接收方需要更大的存储空间已缓存分组。

     - 与停等协议的对比：

       左边对应于停等协议，空中只有一个分组；右边对应于流水线协议，空中有多个分组，并且接收方发送多个ACK。显著提高了网络资源的利用率。

       ![image-20210419163451600](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419163451600.png)

4. 滑动窗口协议（Sliding-window protocol）：实现流水线机制

   - 窗口：

     - 可以认为是允许使用的序列号范围，也可以是管理的那些还没有确认的消息。用来管理那些还没发出去、还没确认的分组。
     - 如果窗口尺寸为N，表示最多有N个等待确认的消息。

   - 滑动窗口

     - 在实际中，随着协议的运行，窗口在序列号空间内向前滑动。因为比如说1-5的序列号用完了，接下来就要使用6-10的序列号，所以窗口就要移动到对应的位置。

   - 如图：

     ![image-20210419164654586](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419164654586.png)

     当黄色部分的分组被确认时，窗口就可以向右移动了。

   - 两个滑动窗口协议：GBN（Go-Back-N），SR。



### 2.5.2 Go-Back-N协议

1. 发送方：

   - 分组头部包含有k-bit序列号

   - 窗口尺寸为N，最多允许N个分组未确认。

   - 图示：

     ![image-20210419165553605](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419165553605.png)

     - 窗口最小的序列号定义为send_base，上图有8个分组已经发送还未确认。
     - nextseqnum表示可以用来发送的序列号，上图有6个，也就是说下一个发送分组使用的序列号为nextseqnum。
     - 右边空的小矩形是还不能使用的序列号。

   - 当收到ACK(n)时，表示确认从开始到序列号n（包括n）的分组均已被正确接收。——**累积确认机制**。

     可能会收到重复的ACK，但不是大问题。

   - 为空中的分组设置计时器（timer）

   - 超时Timerout(n)事件：超时事件是发生在某一个序列号上的，一旦超时，就需要重传序列号大于等于n、还未收到ACK的分组。

     > 可能会造成资源的浪费。

   - 发送方的扩展FSM（有穷状态自动机）：称为扩展FSM，是因为包含了变量。

     ![image-20210419173132609](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419173132609.png)

2. 接收方：

   - 没有缓存。
   - ACK机制：发送拥有最高序列号的、已被正确接受的分组的ACK。
     - 维持着一个expectedseqnum变量，当前期望的收到的分组序列号。
   - 可能会有乱序到达的分组
     - 停等协议没有乱序到达的分组，因为它都是发一个然后等待。
     - 比如说现在需要5号，但是来了7号，5号还没到。处理方式是直接丢弃当前收到的并不是所期待的分组。并且重新确认序列号最大的、按序到达的分组，也就是4号。
   
3. 示例：

   ![image-20210419205823206](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419205823206.png)

4. 练习题：

   ![image-20210419205841214](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419205841214.png)



#### 2.5.3 Selective Repeate协议

1. 引入：GBN有什么缺陷？

   GBN在重传时会重传很多个分组，当某个分组n丢失时，它会重传n以及n以后的分组，这其实不必要的，只会导致网络中充斥着重传的分组，影响性能。

   改进：不使用累积确认机制，并且会将乱序的分组缓存起来，而不是丢弃。也就是SR协议。

2. SR协议

   - 接收方对每个分组单独进行确认。

   - 修改接收方允许接收多个分组，设置缓存机制，缓存乱序到达的分组。

   - 发送方只重传没有收到ACK的分组

     - 为每个分组设置单独的定时器，当某个定时器停止后，依然没有收到ACK时，就重传此分组。

   - 发送方的窗口依然是N个连续的序列号，以此限制已发送且未确认的分组。

   - 和GBN协议相比，多了接收方的窗口。

     ![image-20210419221150702](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419221150702.png)

     - 发送方窗口和接收方窗口不是同步的，这也是分布式系统网络的一个特征。

   - 伪代码来刻画SR协议的细节

     ![image-20210419221234631](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419221234631.png)

   - 示例

     ![image-20210419221255026](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419221255026.png)

   - 困境

     ![image-20210419221311206](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210419221311206.png)

     在这个场景中：

     - 序列号是0,1,2,3，四个序列号重复使用。

     - 窗口的尺寸是3。

     - 对于场景a，发送方正确地发送了pkt0、1、2，接收方也正确地接收，窗口向前滑动；但是3个ACK全丢，于是发送方会到达pkt0的超时状态，然后重发分组0，接收方收到序列号为0的分组。

     - 对于场景b，发送方正确地发送了pkt0、1、2，接收方也正确地接收，窗口向前滑动；ACK0到达发送方，然后发送方滑动窗口并且发送pkt3，但是pkt3丢失了，接下来发送方收到ACK1，继续滑动窗口并且发送pkt0，接收方成功接收pkt0。

     - 困境：

       :o2: 问题：对于a，b两个场景，接收方可以区分吗？

       1. 我们来看：两个场景中最后发送的pkt0显然使具有不同意义的。场景a中的pkt0是重传的分组，场景b中的pkt0是发送的第5个分组。
       2. 对于分布式系统：是无法知晓发送方发生了什么的，所以无法区分这两种情况，就会出错。尤其是场景a，因为序列号也在窗口中，它就会把这个重复的分组当成新的分组接收。

       :o2: 原因：可用序列号少，窗口大小较大。

       :o2: 解决：序列号空间大小和窗口尺寸需要满足下面的条件

       > 假如序列号的位数是k，那么可用的序列号有 2^k^ 。发送方窗口的尺寸N~sender~和接收方的窗口尺寸N~receiver~要满足
       >
       > N~sender~ + N~receiver~ <= 2^k^