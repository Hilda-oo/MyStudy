#  计算机网络

## 1、应用层

### 1.1 网络应用的体系结构

> 网络应用的特点，与单机应用的本质性的不同：在网络的两端都会有一些软件或应用程序进行交互

#### 1.1.1 客户机/服务器结构（Client/Server,C/S）

1. 一个服务器，很多个客户机使用服务，服务器对外提供服务
2. 服务器
   - 永久性访问地址、域名（不能随意改）
   - 7*24小时提供服务
   - 利用大量服务器实现可扩展性，同时处理大量用户的请求。
3. 客户机
- 与服务器通信
   - 间歇性接入网络，使用时才接入
   - 可能使用动态的IP地址，因为不需要对外提供服务
   - 客户机之间不会直接通信
4. 例子：Web。服务器上运行Web服务器软件，响应请求；常见的客户机就是PC、Mac等，运行着一些浏览器，发送请求。

#### 1.1.2 点对点结构（Peer-to-Peer,P2P）

1. 特点：
   - 没有永远在线的服务器，主机都是平等的
   - 任意端系统/节点之间可以直接通讯
   - 间歇性接入网络（使用时）
   - 可能改变IP地址
   - 例子：文件共享、文件下载

2. 与C/S有什么不同？或者说比较C/S，P2P有什么优缺点？

   - 优点：高度可伸缩。

   - 缺点：实现复杂，难于管理。

#### 1.1.3 混合结构（Hybrid）（前两者混合）

1. 例子：Napster

   - 文件传输使用P2P结构

   - 文件搜索使用C/S结构——集中式。每个节点向中央服务器报告自己的内容（文件名、文件属性等）或者提交查询请求（文件名、文件属性等）。

   > 下图说明：
   >
   > 1. 因为是混合结构，所以需要一个中央服务器；
   > 2. 中央服务器和利用者、提供者构成C/S结构；
   > 3. 利用者和提供者之间直接传输文件构成P2P结构。
   >

   >![image-20210410205049919](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205049919.png)
=======
   > 

思考题：

1. 为每种体系结构找出5种以上的网络应用。
2. 从多个方面/角度对比三种体系结构的优缺点。





###  1.2 网络应用的需求与传输服务

#### 1.2.1 主要需求：

1. 数据丢失（data loss）/可靠性（reliability）

   - 有些网络能够容忍一定的数据丢失：网络电话、视频（表现为视频质量不佳）

   - 相反有些网络要求100%可靠的传输：网上银行

2. 时间(timing)/延迟(delay)
   - 有些应用只有在延迟足够低时才有效
   - 另一种情况：网络电话/网络游戏，比如打电话对方已经说话了，但是过了一分钟才传到己方这边。
   - 当延迟高到一定程度时，可以说这个网络应用实际上已经无效了。

3. 带宽(bandwidth)

   - 某些应用只有在带宽达到最低要求时才“有效”。
     - 比如网络在线看视频，如果带宽比较低的话，视频是很卡的，不连续的。

   - 弹性应用：可以适应任何带宽
     - 比如：email、文件下载（网速快、下得快，网速慢、下的慢，但都能下）

4. 还有一些其他的，比如说安全性的要求。

5. 典型网络应用对传输服务的需求 

   ![image-20210410205143035](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205143035.png)

   

   

#### 1.2.2 Internet（主流网络）提供的传输服务

1. TCP服务
   - 面向连接：客户机/服务器进程间需要建立连接。
   - 可靠的传输：可以将底层的不可靠转化为可靠的。
   - 流量控制：发送方不会发送速度过快，超过接收方的处理能力。
   - 拥塞控制：对整个网络启动的机制，当网络负载过重时能够限制发送方的发送速度。
   - 不提供时间/延迟保障、最小带宽保障

2. UDP服务

   - 无连接
   - 不可靠的数据传输
   - 不提供可靠性保障、流量控制、拥塞控制、延迟保障、带宽保障
   - UDP做的是任何一个传输层服务都必须要做的基本的事情，除此之外都不做。其优点传输过来限制少，使得在应用层可以做很多事情。

3. 典型网络应用所使用的传输层服务

   ![image-20210410205210192](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205210192.png)

   



### 1.3 Web应用

> 万维网（World Wide Web）发明人：Tim Berners-Lee

#### 1.3.1 Web构成

1. Web的构成是一个一个网页，并且网页之间互相连接，从而形成一个庞大的信息网络和内容网络，甚至发展成服务网络。
2. 网页（Web Page）包含多个对象：
   - HTML文件、JPEG图片、视频文件、动态脚本等。
   - 包含基本HTML文件：包含对其他对象引用的链接。
3. 对象的寻址（addressing）
   - Web对象的标识是URL（Uniform Resource Locator），即统一资源定位器。
   - URL基本格式：Scheme://host:port/path（协议://主机的域名或IP地址：端口号/路径）
   - 例子：**www.someshool.edu/**someDept/pic.gif。其中协议被省略，默认为HTTP://，加粗部分是主机名，剩余部分为路径（具体到文件pic.gif）。

#### 1.3.2 HTTP协议概述

> 万维网应用遵循 **超文本传输协议（HyperText Transfer Protocol，HTTP）**。

1. 采用C/S结构

   - 客户——Browser：浏览器，作用是请求、接收、展示Web对象。
   - 服务器——Web Server：响应客户的请求，发送对象。
     - 最典型的WebServer软件是Apache软件，是现在事实上的标准。

2. HTTP版本：

   - 1.0：RFC 1945
   - 1.1：RFC 2068

3. 使用TCP传输服务：流程如下

   - 服务器在 **80端口** 等待客户的请求
   - 浏览器发起到服务器的 **TCP连接**（创建套接字 **Socket**）
   - 服务器接受来自浏览器的TCP连接
   - 浏览器（HTTP客户端）与Web服务器（HTTP服务器）交换HTTP消息（请求和响应消息）
   - **关闭TCP连接**

4. HTTP应用协议是一个**无状态**应用协议，服务器 **不维护** 任何有关客户端过去所发请求的消息（即使是2分钟前）。

   - 一般来说更喜欢使用无状态机制，因为有状态的协议更复杂：

     > 需要维护状态（维护历史信息）；如果客户或服务器失效，会产生状态不一致，解决这种问题代价高。

#### 1.3.3 HTTP连接

> HTTP依靠TCP建立连接。

1. HTTP连接的两种类型

   - 非持久性连接（Nonpersistent HTTP）

     - 每个TCP连接最多允许传输 **一个** 对象，然后就会被关闭。HTTP1.0早期版本使用这种机制。

     

   - 持久性连接（Persistent HTTP）

     - 每个TCP连接允许传输 **多个** 对象，HTTP1.1版本使用这种机制。

   - 两者之间的不同？

2. 非持久性连接（以例子说明）

   - 详细例子

     ![image-20210410205302891](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205302891.png)

       ![image-20210410205401765](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205401765.png)

     

   - 一个非持久性连接的**响应时间分析与建模**

     > RTT(Round Trip Time):**从**客户端**发送**一个很小的数据包**到**服务器并**返回**所经历的时间。

     响应时间(Response time) 分解:

     - 发起、建立TCP连接：1个RTT

     - 发送HTTP请求消息到HTTP响应消息的前几个字节到达：1个RTT

     - 响应消息中所含文件/对象传输时间（完全接收响应消息，包含解析、文件之类的）。

     - 总结：Total = 2RTT+文件发送时间

       ![image-20210410205435540](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205435540.png)

       

   - 特性总结：
     1. 一个TCP连接只允许传输 **一个** 对象，然后就会被关闭。
     2. 一次非持久性连接的响应时间为：Total = 2RTT+文件发送时间。
   - 缺点：
     - 慢：每个对象都需要2个RTT以上的时间才能获得（**串行**）。
     - 操作系统需要为每个TCP连接开销资源（overhead）。

   > 于是就会想可以并行吗？但是就会给服务器端造成很大的负担。TCP连接是一个宝贵资源，都是需要代价的。

3. 持久性连接（改进）

   - 发送响应之后，服务器保持TCP连接的打开状态，后续的HTTP消息可以通过这个连接继续发送。
   - 无流水(pipelining)的持久性连接：
     - 客户端只有收到前一个响应后才发送新的请求。
     - 每个被引用的对象耗时1个RTT。
   - 带有流水机制的持久性连接（HTTP1.1的默认选项）
     - 客户端只要遇到**一个**引用对象就尽快发出请求
     - 理想情况下，收到**所有的**引用对象只需耗时约1个RTT。



#### 1.3.4 HTTP消息格式

1. HTTP协议有两类消息：请求消息（request）、响应消息（response）。都是使用ASCII码，直接可读。

2. 请求消息

   例如：![image-20210410205510933](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205510933.png)

   格式：

   ![image-20210410205626120](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205626120.png)

   

   - 请求消息会携带数据吗？
     - 会，比如说某些请求需要填写用户名信息等，这些被放在 **Entity Body** 消息体中。
   - 那如何上传输入数据呢？
     - POST方法：在请求消息的消息体中上传客户端的输入，然后服务器从消息体获取数据。
     - URL方法：当上传输入的消息较少时，使用GET方法，输入信息通过request行的URL字段上传。
   - HTTP中方法的类型：
     - HTTP/1.0
       - GET方法：从浏览器中获得东西
       - POST方法：向服务器中提交数据
       - HEAD方法：请服务器不要将所请求的对象放入响应消息中。
     - HTTP/1.1
       - PUT：将消息体中的文件上传到URL字段所指定的路径。可以支持向WEB上传文件并保存。
       - DELETE：删除URL字段所指的文件。

3. 响应消息

   例如：

   ![image-20210410205532511](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205532511.png)

   

   - 响应状态码：
     - 200 OK
     - 301 该网页被永久性移走（Moved Permanently）
     - 400 （Bad Request）
     - 404  找不到网页（Not Found）
     - 505 （HTTP Version Not Supported）



#### 1.3.5 Cookie技术

1. 为什么需要Cookie技术

   HTTP协议是无状态的，但是很多应用需要服务器掌握客户端的状态，需要会话状态的，如网上购物。所以需要Cookie技术。

2. Cookie技术的含义

   - Cookie技术是某些网站为了辨别用户身份、进行session跟踪而**储存在用户本地终端上的数据**（通常需要加密）。
   - RFC6265

3. Cookie的组件

   - HTTP响应消息的cookie头部行
   - HTTP请求消息的cookie头部行
   - 保存在客户端主机上的cookie文件，由浏览器管理。
   - web服务器的后台数据

4. Cookie原理

   ![image-20210410205828108](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205828108.png)

   

5. Cookie的作用

   - 身份认证
   - 购物车
   - 推荐……

6. 隐私问题



#### 1.3.6 Web缓存/代理服务器技术

1. 功能

   在不访问服务器的前提下满足客户端的HTTP请求。

2. 性能（即为什么要发明这项技术？）

   - 缩短客户请求的响应时间
   - 减少机构/组织的流量
   - 在大范围网络内实现有效的内容分发

3. 结构

   - 增加一个缓存/代理服务器。用户设定浏览器通过缓存进行Web访问。
   - 浏览器向缓存/代理服务器发送所有的HTTP请求
     - 如果缓存中有所请求对象，缓存返回对象。
     - 如果没有，缓存服务器就会向原始服务器发送该HTTP请求，获取对象，返回给客户端并保存该对象。
   - 缓存既充当客户端，也充当服务器。
   - 一般有ISP（Internet服务提供商）架设。

   ![image-20210410205748446](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205748446.png)

   

4. 改善性能的例子

   ![image-20210410205859021](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205859021.png)

   ![image-20210410205925455](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205925455.png)

   ![image-20210410205943164](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210410205943164.png)

   

5. 如何判别缓存服务器和原始服务器上的对象是否是一致的？

   条件性GET方法：主要思想是如果缓存有最新的版本，则不需要发送请求对象。

   - 缓存：在HTTP请求消息中声明所持有版本的日期 `If-modified-since:< date >`，然后将请求消息发送给原始服务器。
   - 原始服务器：根据时间判断——
     - 如果缓存的版本是最新的，则响应消息中不包含对象，但包含状态码 `304 Not Modifiled`。这样的较空的响应消息是不需要多少带宽的。
     - 如果不是最新的，就将对象放在响应消息中，并包含状态码`200 OK`。

     

### 1.4 Email应用

#### 1.4.1 Email应用的构成

1. 构成组件

   邮件客户端、邮件服务器、SMTP协议（Simple Mail Transfer Protocol）。

2. 邮件客户端：在Email应用的外围

   - 读、写email信息
   - 与服务器交互，收、发Email消息
   - 例如有Outlook、Foxmail、Thunderbird。
   - Web客户端，使用Web Email时，浏览器也是一个客户端。

3. 邮件服务器：Email应用的核心

   - 邮箱：为每个人创建一个邮箱，存储发给该用户的Email。
   - 消息队列：创建一个消息队列，存储等待发送的Email。服务器会代替客户端将邮件送到指定的地方。

4. SMTP协议（RFC 2821）

   - **邮件服务器之间**传递消息所使用的协议。
     - 客户端：发送消息的服务器。
     - 服务器：接收消息的服务器。

   - 使用TCP进行email消息的可靠传输。

     - 端口为25

   - 传输过程的三个阶段

     - 握手连接 **→** 消息传输 **→** 关闭连接

   - 采用命令/响应交互模式

     > HTTP采用请求/响应交互模式，都是一样的。

     - 命令（command）：ASCII文本
     - 响应（response）：状态代码和语句

   - 特点

     - 使用持久性连接
     - 要求消息必须由7位ASCII码构成
     - SMTP服务器利用CRLF.CRLF（回车换行 **.** 回车换行）确定消息的结束

   - 与HTTP协议的对比

     - HTTP：拉式（pull），客户端需要到服务器把网页拉回到本地。

       SMTP：推式（push），由发送方主动建立连接，把消息推送到接收方。

     - HTTP：每个对象都封装在独立的响应消息中。

       STMP：多个对象在由多个部分构成的消息中发送。

     - 都使用命令/响应 or 请求/响应的交互模式。

       命令和状态代码都是ASCII码。

5. 采用邮件服务器的好处

   我们的手机不能保证7*24小时在线，没办法时刻接收到别人发的邮件；如果不使用邮件服务器，给别人发邮件的时候，一遍发不成功就需要不停地尝试，当对方不在线时，就需要等待，导致电脑不能关闭，这也会导致一个负担。

6. 在最初设计中，Email消息只能包含7位ASCII码。

7. Email应用例子

   - 示例
     
     ![image-20210412081502190](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412081502190.png)
     
     - ①：Alice利用自己的邮箱客户端写了一个消息。
     - ②：她把消息发送给自己的邮件服务器，发送到邮件发送消息队列里去。
  - ③④：Alice的邮件服务器把队列中的消息发送到Bob的邮件服务器。
     - ⑤：消息进入Bob的邮件服务器。
  - ⑥：Bob在某个时刻利用自己的邮件客户端从服务器上获取消息。

   > 结论：email应用是一个异步应用，发送方发送消息和接收方接收消息并不要求同时。

   - SMTP交互示例
   
     ![image-20210412081545292](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412081545292.png)



#### 1.4.2 Email的消息格式与POP3协议

1. Email消息格式

   - SMTP是email消息的传输/交换协议。

   - 文本消息格式标准（RFC 822）

     - 头部行（header）：**1.** To   **2.** From    **3.** Subject   ——与SMTP命令不同
     - 消息体（body）：消息本身，并且只能是ASCII字符。

     ![image-20210412081617055](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412081617055.png)
     
     

2. 如何支持非文本的消息传输呢？

   MIME：多媒体邮件扩展 （RFC 2045,2056）

   - 通过在邮件头部行增加额外的行来声明MIME的内容类型。声明包含：

     - 有多媒体内容
     - 采用什么格式
     - 使用什么方法解码

     ![image-20210412083631313](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412083631313.png)
     
     

3. 邮件访问协议：从服务器获取邮件

   > 由此可看出，一个email应用可以综合的使用多个协议，此点与Web应用不同。

   :one: 邮件访问协议有

   - POP（Post Office Protocol）：认证/授权阶段（客户机和服务器之间，认证一下自己确实是此邮箱的拥有者），从邮件服务器上下载邮件。
   - IMAP（Internet Mail Access Protocol）：更多功能，实现复杂，现常用。
   - HTTP:163,QQ Mail。例如从Web服务器上获取邮件时，就是使用的HTTP协议。

   :two: POP3协议

   - 认证过程：使用命令/响应交互模式。

     客户端命令：User(声明用户名)，Pass(声明密码)。

     服务器响应：+OK(合法用户)，-ERR(用户名或密码不对)。

   - 事务阶段：

     List：列出消息数量

     Retr：用编号获取消息

     Dele：删除消息

     Quit：退出

     ![image-20210412083957551](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412083957551.png)

     

   - **下载并删除**模式

     下载后服务器删除邮件，用户如果更换了客户端软件，无法重读该邮件。

     **下载并保持**模式

     即不删除，不同客户端都可以保留消息的拷贝，但大量的消息都会保存在邮箱里。

   - POP是无状态的

   :three: IMAP协议
   
   - 优点：
     - 所有消息统一保存在一个地方：服务器
     - 允许用户利用文件夹组织消息
     - 支持跨会话的用户状态：可以在服务器上创建文件夹之后，把不同的消息放在不同的文件夹中，所有的客户端上，在此文件夹组织上的消息是一致的。
     - 支持文件搜索……



### 1.5 DNS应用

#### 1.5.1 DNS概述

1. 域名服务（Domain Name System）：解决互联网上主机/路由器的识别问题。

   网络上，主机具有唯一的 **IP地址** ；日常生活中标识主机的是 **域名**，便于人来识别、记忆。

2. DNS服务

   > IP地址和域名如何映射呢？
   >
   > 通过域名解析系统DNS，它能将域名翻译为IP地址。

   :one: 域名向IP地址的翻译

   - 多层命名服务器构成的分布式数据库

   - DNS本身是一个应用层协议，在应用层协议之上有应用层软件负责完成应用层名字的解析。

     - 提供的是互联网的核心功能，但是 是由应用层协议在应用层完成的。

     > 为什么不将DNS放到相对底层呢？应用层不是留给做应用的来发挥的吗？为什么要在应用层来实现呢？效果怎么样？
     >
     > **解答**：
     >
     > 在应用层实现的方式非常符合互联网TCP/IP协议栈的原则的，希望端系统很复杂，但网络核心越简单越好，于是在端系统应用层实现，就可以降低网络核心的的复杂性。

   :two: 提供主机别名、邮件服务器别名。

   :three: 负载均衡：Web服务器。

   - 比如大的门户网站，显然不是一台服务器提供服务，此时打量用户请求可以使用DNS来做负载均衡。当进行域名向IP地址进行翻译时，可以提供多个映射，即Web服务器的IP地址，如果没有新的服务，就将服务器的地址调整一下顺序，这样服务器就可以轮流着来提供服务。

   > 为什么不使用集中式的DNS呢？
   >
   > 如果采用集中式的DNS，会出现以下问题：
   >
   > 1. 单点失败问题：如果使用一台集中式服务器或者多台服务器集中在一起提供服务，一旦这个集中服务点down掉，整个互联网就会瘫痪。
   > 2. 流量问题：几十亿服务主机都到这个点来请求服务，耗费的流量是庞大的。
   > 3. 距离问题：只有一个DNS服务，是不可伸缩的，就会存在距离很远的主机，延迟就会很长，服务性差。

3. DNS的分布式层次式数据库

   > 分布式：分布广泛；层次式：分层。

   ![image-20210412084102237](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084102237.png)

   - 查询IP地址的例子

     当客户想要查询www.amazon.com的IP时，经过如下步骤：

     - 客户端查询根服务器，找到com域名解析服务器。
     - 客户端查询com域名解析服务器，找到amazon.com域名解析服务器。
     - 客户端查询amazon.com域名解析服务器，找到www.amazon.com的IP地址。

     由此可见分布式的DNS也有不足，仅这一个查询就需要进行3次查询才能得到结果。

   - DNS根域名服务器

     > 全球有13个根域名服务器，基本在北美。

     - 本地域名解析服务器无法解析域名时，访问根域名服务器。
     - 根域名服务器解析时，如果不知道映射，访问 **权威域名服务器**，从而获得映射，向本地域名服务器返回映射。

   - 顶级域名服务器（TLD,top-level domain）

     - 负责com，org，net，edu等顶级域名和国家顶级域名，如cn，uk，fr等。

     - 顶级域名服务器需要一些组织来维护

       例如：Network Solutions维护con顶级域名服务器。

   - 权威域名服务器

     - 组织的域名解析服务器，提供组织内部服务器的解析服务。

       > 这个组织比如说大学，有自己的网页、自己的邮箱，对外提供服务，此时就需要提供域名解析服务，将自己内部提供的这些服务的域名与IP地址的映射维护起来。

     - 可以由自己维护，也可以委托服务提供商维护。

   - 本地域名解析服务器

     - 不属于层级体系

     - 每个ISP都有一个本地域名服务器，称为默认解析服务器。

     - 作用：当主机进行DNS查询时，查询会先被发送到本地域名服务器，本地域名服务器作为一个代理，将查询转发给层级式的域名解析服务器系统。

     - DNS查询示例

       ① 迭代查询：被查询服务器返回域名解析器的名字，即“我不认识这个域名，但是你可以访问这个服务器”。

       ![image-20210412084231263](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084231263.png)

       

       ②递归查询：将域名解析的任务交给所联系的服务器，即“我不认识这个域名，然后我直接访问可能知道的下一个服务器，最后再一层一层返回”。

       ![image-20210412084400106](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084400106.png)
       
       两种查询的差别？

4. DNS记录缓存和更新

   - 只要域名解析服务器获得域名-IP映射，就缓存这一映射。但不是无限缓存，一段时间后，缓存条目会失效被删除。
   - 本地域名服务器一般会缓存顶级域名服务器的映射。所以根域名服务器很少被访问。
   - 记录的更新/通知机制：RFC 2136



#### 1.5.2 DNS记录和消息格式

1. DNS记录

   - 也被称为资源记录（RR,resource records）。

   - 格式为：（name，value，type，ttl），一个四元组。

   - 不同type，name和value有不同的解释。

     Type = A ：name——主机域名，value——IP地址。

     Type = NS ：name——域（例如edu.cn），value——该域权威域名解析服务器的主机域名（指出此域的域名解析服务器）

     Type = CNAME ：name——某一真实域名的别名（www.ibm.com），value——真实域名（servereast.backup2.ibm.com）

     Type = MX ：value是和name 相对应的邮件服务器

2. DNS协议与消息

   - DNS协议是查询（query）和回复（reply）模式，并且查询和回复的消息格式是一样的。

   - 消息格式：

     - 头部：举两个例子

       identification：16位查询编码，回复使用相同的编码，这样就能去分开这是为某一个查询提供的回复。

       flags：标志位，标志着是查询或回复、是否期望递归、递归是否可用、是否是权威回答。

       ![image-20210412084435688](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084435688.png)

   > DNS是使用TCP还是UDP？
   >
   > **解答：**
   >
   > DNS占用53号端口，同时使用TCP和UDP协议。那么DNS在什么情况下使用这两种协议？
   >
   > DNS在区域传输的时候使用TCP协议，其他时候使用UDP协议。
   >
   > - DNS区域传输的时候使用TCP协议：
   >   - 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。
   >   - TCP是一种可靠连接，保证了数据的准确性。
   >
   > - 域名解析时使用UDP协议：
   >   - 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。

3. 如何注册域名？

   ![image-20210412084658863](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084658863.png)





### 1.6 P2P应用

### 1.6.1 原理与文件分发

1. 就文件分发而言，P2P 与 C/S 的对比

   **假定：**

   ![image-20210412084720243](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084720243.png)

   -   一个文件服务器，上面有一个大小为F的文件。
   -  有N个结点/主机，接入互联网。
   - 从服务器向n个节点分发这个文件。
   - 假定核心网络有足够的带宽，所以这个性能瓶颈主要在服务器接入网络和节点接入网络。
   - 服务器向网络上传文件，带宽设为u~s~ 。
   - 每个节点从网络上获取文件，设节点i的下载带宽为 d ~i~ 。
   - 在 P2P 模式下，每个节点向其他的节点分享文件块，设节点的上传带宽为u ~i~ 。

   **问题**：从一个服务器向N个节点分发一个文件需要多长时间？

   - C/S模式：

     - 服务器串行的发送N个副本：NF/u~s~
     - 客户机 i 下载：F/d~i~
     - 那么最后的时间应该为 （下载文件最慢的那个客户机需要的时间） 和 （服务器上传N个副本的时间） 之间的最大值。

     > **Total Time = Max {  NF / u~s~  ，F / min(d~i~)   }**
     >
     > 从最后结果来看，当N较大时，时间一般取前者，并且是与N呈线性增长的。

   - P2P模式：

     - 客户机之间可以互相通信，上传或下载片段，所以服务器只需要发送一个副本：F/u~s~
     - 客户机 i 下载：F/d~i~
     - 无论哪种方式，最终都需要下载 NF 比特，每个客户机才能接收到文件。
     - 最快的可能上传的速率为：u~s~ + ∑ u~i~ (即服务器和所有客户机一起上传)。
     - 那么最后时间：Time = Max {  F/u~s~ ,  F / min(d~i~) ,  NF/ (u~s~ + ∑ u~i~)  }

   - C/S vs P2P 直观图

   ![image-20210412084927992](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412084927992.png)

   > P2P方式实现文件分发比传统的C/S方式要快。   

2. 例子 BitTorrent

   > 节点上传的速率高，就能找到更好的 “交易伙伴（文件提供方/接收方）”，从而更快地获取文件（成为其他节点的Top4）。

 ![image-20210412085251905](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412085251905.png)

![image-20210412085538087](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412085538087.png)

![image-20210412085548475](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412085548475.png)

### 1.6.2 索引技术

> 在P2P中经常需要搜索信息。

1. P2P系统的索引：信息到节点位置（IP地址+端口号）的映射。

   例子：

   - 文件共享
     - 利用索引动态跟踪节点所共享的文件的位置
     - 节点需要告诉索引它拥有哪些文件
     - 有需要的节点会搜索索引，从而获知能够从哪里/谁得到哪些文件
   - 即时消息（QQ）
     - 索引负责将用户名映射到位置（比如说IP地址+端口号）
     - 当用户开启IM应用时，需要通知索引它的位置
     - 当发起聊天时，节点就会检索索引，确定用户的IP地址。

2. 索引的设计

   - 集中式索引

     > Napster最早采用这种设计。

     - 有一个中央服务器，当节点加入时，必须告诉中央服务器自己的IP地址和内容。
     - 当一个节点Alice向中央服务器查找 “ Hey Jude” 这个文件时，通过查找，中央服务器会告诉Alice节点Bob有这个文件，然后Alice与Bob通信，获取这个文件。
     - 缺点：虽然内容和文件传输是分布式的，但是内容定位是高度集中式的。就会导致单点失效问题、性能瓶颈、版权问题。

   - 洪泛式（分布式索引）查询（Query flooding）：

     - 完全分布式架构

     - 每个节点只对自己共享的文件进行索引。

       > 那么怎么能够查询所有的文件呢？

     - 覆盖网络（overlay network）：节点X和Y之间如果有TCP连接，那么构成一个边，所有的活动节点和边就构成了覆盖网络。这是一个虚拟网络，边是虚拟链路，节点的邻居一般少于10个。

     - 查询方法就叫做洪泛式查询：

       通过已有的TCP连接发送查询消息给连接上了的节点。

       任何收到查询消息的节点都将转发该查询信息给自己有连接的节点。（所以叫洪泛式查询）

       如果查询命中，则利用反向路径发回查询节点。

     - 缺点：消耗大量带宽，造成网络拥塞；消息泛滥，给网络带来很大负担；节点刚刚加入时，需要的处理比较复杂。

   - 层次式覆盖网络（介于前两者之间）
     - 节点划分为两类：超级节点、普通节点。普通节点之间没有TCP连接，与超级节点之间维护着TCP连接；某些超级节点和超级节点之间会维护TCP。
     - 超级节点负责跟踪子节点的内容，提供索引。
     - 普通节点查询时，会向它的超级节点查询，然后超级节点与超级节点通信进行查询。
     
     ![image-20210412092019809](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412092019809.png)
     
     

3. 案例应用Skype

   ![image-20210412092058455](C:\Users\蔲丫丫\AppData\Roaming\Typora\typora-user-images\image-20210412092058455.png)

   


